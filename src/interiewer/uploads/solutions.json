[
          {
                    "title": "two-sum",
                    "solution": "Here's a concise solution to the Two Sum problem, utilizing a one-pass hash table approach that captures the essence of the problem based on the provided information:\n\n### Problem Statement\nGiven an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n### Optimized Approach: One-pass Hash Table\nThe key idea is to traverse the array while maintaining a hash table to keep track of the indices of the elements we've seen so far. For each element, we check whether its complement (i.e., `target - num`) exists in the hash table.\n\n### Complexity\n- Time Complexity: **O(n)** - We traverse the list only once.\n- Space Complexity: **O(n)** - In the worst case, we store all elements in the hash table.\n\n### Code Implementation (Python)\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        num_map = {}  # Hash map to store number and its index\n        for index, num in enumerate(nums):\n            complement = target - num\n            if complement in num_map:\n                return [num_map[complement], index]  # Found the solution\n            num_map[num] = index  # Store index of the current number\n        return []  # In case no solution exists (though we assume there is one)\n```\n\n### Code Implementation (Java)\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        Map<Integer, Integer> numMap = new HashMap<>();\n        for (int i = 0; i < numbers.length; i++) {\n            int complement = target - numbers[i];\n            if (numMap.containsKey(complement)) {\n                return new int[] { numMap.get(complement), i }; // Found the solution\n            }\n            numMap.put(numbers[i], i); // Store index of the current number\n        }\n        return new int[] {}; // In case no solution exists (though we assume there is one)\n    }\n}\n```\n\n### Code Implementation (C++)\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> numMap;  // Hash map to store number and its index\n        for (int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if (numMap.find(complement) != numMap.end()) {\n                return {numMap[complement], i}; // Found the solution\n            }\n            numMap[nums[i]] = i; // Store index of the current number\n        }\n        return {}; // In case no solution exists (though we assume there is one)\n    }\n};\n```\n\n### Explanation\n1. We iterate through the input list `nums`.\n2. For each number, we calculate its complement (the number we need to find to reach the target).\n3. If this complement is already in the hash table, it means we have already encountered the required number, so we return their indices.\n4. If not, we update the hash table with the current number and its index.\n\nThis approach is efficient and elegantly solves the problem in a single pass through the array."
          },
          {
                    "title": "add-two-numbers",
                    "solution": "Here's a concise and clear solution for the \"Add Two Numbers\" problem, implementing the operations on two linked lists representing reversed numerical values.\n\n### Problem Description\nGiven two linked lists representing non-negative integers, where each node contains a single digit, add the two numbers and return the sum as a linked list. The digits are stored in reverse order.\n\n### Approach\n1. Create a dummy node to simplify adding new nodes and keep track of the resulting linked list.\n2. Initialize a pointer (`curr`) to the dummy node and a variable (`carry`) to manage carry-over during addition.\n3. Traverse both linked lists simultaneously, summing corresponding values and applying the carry:\n   - If one list is shorter, treat its missing values as zero.\n   - Calculate the sum of the two digits and the carry.\n   - Create a new node for the sum's last digit and adjust carry for the next iteration.\n4. Continue until all digits are processed and there is no remaining carry.\n5. Return the linked list starting from the next node of the dummy node.\n\n### Code Implementation\n\n**C++**:\n```cpp\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode(0);\n        ListNode* curr = dummy;\n        int carry = 0;\n\n        while (l1 != nullptr || l2 != nullptr || carry) {\n            int sum = carry;\n            if (l1 != nullptr) {\n                sum += l1->val;\n                l1 = l1->next;\n            }\n            if (l2 != nullptr) {\n                sum += l2->val;\n                l2 = l2->next;\n            }\n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n        }\n        \n        return dummy->next;\n    }\n};\n```\n\n**Java**:\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        int carry = 0;\n\n        while (l1 != null || l2 != null || carry != 0) {\n            int sum = carry;\n            if (l1 != null) {\n                sum += l1.val;\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                sum += l2.val;\n                l2 = l2.next;\n            }\n            carry = sum / 10;\n            curr.next = new ListNode(sum % 10);\n            curr = curr.next;\n        }\n\n        return dummy.next;\n    }\n}\n```\n\n**Python**:\n```python\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        dummyHead = ListNode(0)\n        curr = dummyHead\n        carry = 0\n\n        while l1 or l2 or carry:\n            sum = carry\n            if l1:\n                sum += l1.val\n                l1 = l1.next\n            if l2:\n                sum += l2.val\n                l2 = l2.next\n            \n            carry = sum // 10\n            curr.next = ListNode(sum % 10)\n            curr = curr.next\n\n        return dummyHead.next\n```\n\n### Complexity Analysis\n- **Time Complexity**: O(max(N, M)), where N and M are the lengths of the two linked lists.\n- **Space Complexity**: O(max(N, M)) for the resulting linked list. \n\nThis solution efficiently handles any carry and simplifies the addition of the two numbers represented as linked lists."
          },
          {
                    "title": "longest-substring-without-repeating-characters",
                    "solution": "Here is a clear and concise solution to the problem of finding the length of the longest substring without repeating characters. This solution uses the sliding window technique along with a hash map or set to keep track of characters.\n\n### Problem Statement\nGiven a string `s`, find the length of the longest substring without repeating characters.\n\n### Approach\n1. Utilize a hash map (or set) to track unique characters in the current substring.\n2. Use two pointers (`i` for the start and `j` for the end) to represent the boundaries of the current substring.\n3. Iterate through the string with the `j` pointer:\n   - If the character at `j` is not in the hash set, it means we have a unique character. Add it to the set, and update the maximum length.\n   - If the character is already in the set, increment the `i` pointer (move the start) and remove characters from the set until the character at `j` can be added without duplication.\n4. Return the maximum length found.\n\n### Code Implementation\nHere are implementations in Java, C++, and Python:\n\n#### Java\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int i = 0, j = 0, max = 0;\n        Set<Character> set = new HashSet<>();\n        \n        while (j < s.length()) {\n            if (!set.contains(s.charAt(j))) {\n                set.add(s.charAt(j++));\n                max = Math.max(max, set.size());\n            } else {\n                set.remove(s.charAt(i++));\n            }\n        }\n        \n        return max;\n    }\n}\n```\n\n#### C++\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_set<char> set;\n        int i = 0, j = 0, maxLen = 0;\n        \n        while (j < s.length()) {\n            if (set.find(s[j]) == set.end()) {\n                set.insert(s[j++]);\n                maxLen = max(maxLen, j - i);\n            } else {\n                set.erase(s[i++]);\n            }\n        }\n        \n        return maxLen;\n    }\n};\n```\n\n#### Python\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        char_set = set()\n        i, j, max_length = 0, 0, 0\n        \n        while j < len(s):\n            if s[j] not in char_set:\n                char_set.add(s[j])\n                max_length = max(max_length, j - i + 1)\n                j += 1\n            else:\n                char_set.remove(s[i])\n                i += 1\n        \n        return max_length\n```\n\n### Explanation\n- **Initialization**: Before starting, we initialize two pointers and a data structure to hold the unique characters.\n- **Iteration**: As we move the `j` pointer, we check for duplicates and adjust the `i` pointer to maintain a valid substring.\n- **Max Length**: Calculate the maximum length whenever a new unique character is added to the substring.\n- **Return**: After processing all characters, we return the maximum length found.\n\nThis approach ensures each character is processed at most twice, giving a time complexity of O(n), where n is the length of the string. The space complexity is O(min(n, m)), where m is the character set size."
          },
          {
                    "title": "median-of-two-sorted-arrays",
                    "solution": "Here's a concise solution to finding the median of two sorted arrays using the binary search approach. This method efficiently calculates the median with a time complexity of **O(log(min(n1, n2)))**:\n\n```python\nclass Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        n1, n2 = len(nums1), len(nums2)\n\n        # Ensure nums1 is the smaller array\n        if n1 > n2:\n            nums1, nums2, n1, n2 = nums2, nums1, n2, n1\n\n        total = n1 + n2\n        half = (total + 1) // 2\n        low, high = 0, n1\n\n        while low <= high:\n            mid1 = (low + high) // 2\n            mid2 = half - mid1\n\n            # Get L1, L2, R1, R2\n            L1 = nums1[mid1 - 1] if mid1 > 0 else float('-inf')\n            R1 = nums1[mid1] if mid1 < n1 else float('inf')\n            L2 = nums2[mid2 - 1] if mid2 > 0 else float('-inf')\n            R2 = nums2[mid2] if mid2 < n2 else float('inf')\n\n            # Correct partitioning\n            if L1 <= R2 and L2 <= R1:\n                if total % 2 == 0:\n                    return (max(L1, L2) + min(R1, R2)) / 2.0\n                else:\n                    return max(L1, L2)\n            elif L1 > R2:\n                high = mid1 - 1\n            else:\n                low = mid1 + 1\n\n        return 0.0  # If the code reaches here, inputs weren't sorted\n\n# Example Usage\nsolution = Solution()\nprint(solution.findMedianSortedArrays([1, 3], [2]))  # Output: 2.0\nprint(solution.findMedianSortedArrays([1, 2], [3, 4]))  # Output: 2.5\n```\n\n### Explanation:\n1. **Initialization**: First, we ensure that `nums1` is the smaller array. This is important as we will perform binary search on the smaller array to optimize performance.\n\n2. **Binary Search**: We perform a binary search on `nums1` to find the appropriate partition indices:\n   - `mid1` for `nums1` and `mid2` is derived from `mid1` to ensure the halves are valid.\n   \n3. **Boundary Conditions**: Based on the chosen partition, we define the left and right edges of both arrays—`L1`, `R1` (for `nums1`) and `L2`, `R2` (for `nums2`).\n\n4. **Checking Conditions**: We check whether the partitions are valid:\n   - If `L1 <= R2` and `L2 <= R1`, we are done, and we can calculate the median.\n   - If not, we adjust the search boundaries based on the comparison of `L1` and `R2` or `L2` and `R1`.\n\n5. **Result**: Finally, based on the total number of elements, we return the appropriate median value.\n\nThis solution is efficient and handles edge cases gracefully by using `float('-inf')` and `float('inf')` for boundary conditions."
          },
          {
                    "title": "longest-palindromic-substring",
                    "solution": "Here's a clear and concise solution for the problem of finding the longest palindromic substring using the \"Expand Around Center\" approach, which provides an efficient O(n^2) time complexity and O(1) space complexity:\n\n### Solution: Expand Around Center\n\n**Intuition:**\nA palindrome mirrors around its center. For each character and each gap between characters, we expand outwards to check for the longest palindrome.\n\n**Algorithm:**\n1. Initialize `max_str` to the first character and track `max_len` starting from 1.\n2. Iterate through each character in the string:\n   - Expand around each character (for odd-length palindromes).\n   - Expand around the gap between each character and the next (for even-length palindromes).\n3. Keep updating `max_str` whenever a longer palindrome is found during expansion.\n4. Return `max_str`.\n\n**Code:**\n\n```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if len(s) <= 1:\n            return s\n        \n        def expand_from_center(left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1:right]\n\n        max_str = s[0]\n        \n        for i in range(len(s)):\n            # Expand around the center for odd-length palindromes\n            odd = expand_from_center(i, i)\n            if len(odd) > len(max_str):\n                max_str = odd\n            \n            # Expand around the center for even-length palindromes\n            even = expand_from_center(i, i + 1)\n            if len(even) > len(max_str):\n                max_str = even\n\n        return max_str\n```\n\n**Complexity Analysis:**\n- **Time Complexity:** O(n^2) - Each expansion can take O(n) time, and since we have O(n) centers to examine, the overall complexity is O(n^2).\n- **Space Complexity:** O(1) - No additional data structures proportional to the size of the input string are used. \n\nThis solution is efficient and straightforward, making it suitable for a variety of string lengths and content."
          },
          {
                    "title": "reverse-integer",
                    "solution": "Here is the concise solution for the integer reversal problem based on the provided code snippets:\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        int rev = 0;\n\n        while (x != 0) {\n            int digit = x % 10;\n            // Check for overflow before updating rev\n            if (rev > Integer.MAX_VALUE / 10 || rev < Integer.MIN_VALUE / 10) {\n                return 0;\n            }\n            rev = rev * 10 + digit; // Add the digit to rev\n            x /= 10; // Remove the last digit from x\n        }\n        \n        return rev; // return the reversed number\n    }\n}\n```\n\n### Explanation:\n1. The solution initializes `rev` to store the reversed number.\n2. It uses a while loop to extract the last digit of `x` and incorporates it into `rev`.\n3. Overflow checks are done by ensuring that `rev` will remain within the bounds of a 32-bit integer before updating.\n4. Finally, the reversed integer is returned if it is valid, or `0` if there’s an overflow. \n\n### Complexity:\n- **Time Complexity:** O(log(x)), iterating through the number of digits.\n- **Space Complexity:** O(1), as no additional data structures are needed."
          },
          {
                    "title": "string-to-integer-atoi",
                    "solution": "Here is a clear and concise solution for the LeetCode problem of converting a string to an integer (implementing `myAtoi` function).\n\n### Solution Overview\nWe need to handle four primary cases while converting the string to an integer:\n1. Discard all leading whitespaces.\n2. Check for the sign of the number (positive or negative).\n3. Handle potential overflow when converting the digits.\n4. Return 0 for invalid inputs (where non-numeric characters precede the number).\n\n### Implementation\nHere's a clear and optimized version of the code:\n\n```java\npublic class Solution {\n    public int myAtoi(String str) {\n        int index = 0, sign = 1, total = 0;\n        \n        // Check for an empty string\n        if (str.length() == 0) return 0;\n        \n        // Remove leading spaces\n        while (index < str.length() && str.charAt(index) == ' ') {\n            index++;\n        }\n        \n        // Handle signs\n        if (index < str.length() && (str.charAt(index) == '+' || str.charAt(index) == '-')) {\n            sign = (str.charAt(index) == '-') ? -1 : 1;\n            index++;\n        }\n        \n        // Convert number and avoid overflow\n        while (index < str.length()) {\n            int digit = str.charAt(index) - '0';\n            if (digit < 0 || digit > 9) break;\n\n            // Check for overflow\n            if (total > (Integer.MAX_VALUE - digit) / 10) {\n                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n            }\n            \n            total = total * 10 + digit;\n            index++;\n        }\n        \n        return total * sign;\n    }\n}\n```\n\n### Explanation\n1. **Leading Whitespaces**: We skip over any whitespaces until we find a non-space character.\n2. **Sign Handling**: We check for the presence of a '+' or '-' sign to determine if the result should be negative or positive.\n3. **Digit Conversion**: We iterate through the string, converting characters to their numeric values. If an invalid character (non-digit) is encountered, we stop the conversion.\n4. **Overflow Check**: Before updating the total, we check if the next operation will overflow. This ensures that we don't exceed the bounds of a signed 32-bit integer.\n\n### Complexity Analysis\n- **Time Complexity**: O(n), where n is the length of the string. We make a single pass through the string.\n- **Space Complexity**: O(1), since we are using a constant amount of space regardless of the input size.\n\nThis implementation is efficient, straightforward, and adheres to the problem constraints effectively."
          },
          {
                    "title": "regular-expression-matching",
                    "solution": "The problem asked for implementing a pattern matching function using dynamic programming to determine if a string `s` matches a pattern `p` that can include `.` (which matches any single character) and `*` (which matches zero or more of the preceding element).\n\nHere's a concise solution that uses a 2D dynamic programming approach:\n\n### Java Solution\n\n```java\npublic boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n    \n    // Handle patterns like a*, a*b*, etc. which can match an empty string\n    for (int j = 2; j <= n; j++) {\n        dp[0][j] = p.charAt(j - 1) == '*' && dp[0][j - 2];\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p.charAt(j - 1) == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n\n### Explanation:\n\n1. **Initialization**: \n   - Create a DP table `dp` with dimensions `(m+1) x (n+1)` where `m` is the length of `s` and `n` is the length of `p`.\n   - Set `dp[0][0]` to `true` because an empty string matches an empty pattern.\n\n2. **Base Cases**: \n   - The first row `dp[0][j]` is populated based on whether the pattern can match an empty string. If a pattern consists of a character followed by `*`, it can represent an empty match.\n\n3. **DP Filling**:\n   - Iterate through each character in `s` and each character in `p`.\n   - If characters match or the pattern character is `.`, you inherit the matching result from `dp[i-1][j-1]`.\n   - If the pattern character is `*`, check:\n     - If it can represent zero occurrences by looking two spots back in the pattern `dp[i][j-2]`.\n     - If it represents one or more occurrences, ensure that the preceding character matches the current character in `s`.\n\n4. **Final Result**: \n   - The result of whether `s` matches `p` will be found in `dp[m][n]`.\n\n### Complexity:\n- **Time Complexity**: O(m * n), where m is the length of `s` and n is the length of `p`.\n- **Space Complexity**: O(m * n) due to the usage of the DP table.\n\nThis implementation achieves a robust and clear understanding of how to tackle the wildcard matching problem efficiently."
          },
          {
                    "title": "container-with-most-water",
                    "solution": "Here’s a clear and concise solution to the \"Container With Most Water\" problem based on the user-provided information:\n\n## Problem Statement\nYou are given an integer array `height` representing the height of lines drawn at various indices. Your task is to find the maximum amount of water a container can store.\n\n## Solution Overview\nThe solution uses a two-pointer approach:\n1. Initialize two pointers at the start (`left`) and end (`right`) of the array.\n2. Calculate the area between the lines at these two pointers and keep track of the maximum area found.\n3. Move the pointer pointing to the shorter line towards the center because moving the taller line cannot increase the area.\n\n## Code Implementations\n\n### Python\n```python\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n        left = 0\n        right = len(height) - 1\n        maxArea = 0\n\n        while left < right:\n            currentArea = min(height[left], height[right]) * (right - left)\n            maxArea = max(maxArea, currentArea)\n\n            # Move the pointer for the shorter line\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return maxArea\n```\n\n### C++\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int left = 0;\n        int right = height.size() - 1;\n        int maxArea = 0;\n\n        while (left < right) {\n            int currentArea = min(height[left], height[right]) * (right - left);\n            maxArea = max(maxArea, currentArea);\n\n            // Move the pointer for the shorter line\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return maxArea;\n    }\n};\n```\n\n### Java\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int left = 0;\n        int right = height.length - 1;\n        int maxArea = 0;\n\n        while (left < right) {\n            int currentArea = Math.min(height[left], height[right]) * (right - left);\n            maxArea = Math.max(maxArea, currentArea);\n\n            // Move the pointer for the shorter line\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return maxArea;\n    }\n}\n```\n\n## Explanation of the Logic\n- The two-pointer technique allows you to start with the maximum width container and evaluates areas from there.\n- The area is calculated using the formula: `Area = width * height`, where the width is the difference between the indices of the left and right pointers, and the height is determined by the shorter line between the two pointers.\n- By moving the pointer corresponding to the shorter line, the algorithm effectively seeks a potentially larger height without decreasing the width available for the container.\n\n## Complexity Analysis\n- **Time Complexity:** O(n), where n is the number of elements in the height array. Each element is processed at most once.\n- **Space Complexity:** O(1), as the extra space used is constant.\n\nFeel free to use or modify this implementation as needed!"
          },
          {
                    "title": "roman-to-integer",
                    "solution": "Here's a clear and concise solution for converting Roman numerals to integers based on the provided insights and multiple approaches:\n\n## Intuition:\nIn Roman numeral representation, smaller values that precede larger values signify subtraction (e.g., IV = 4). Otherwise, values are added together. \n\n## Algorithm:\n1. Create a mapping of Roman numeral characters to their integer values in a dictionary or map.\n2. Iterate through the string representing the Roman numeral:\n   - If the current value is less than the value of the following character, subtract it from the total.\n   - Otherwise, add the current value to the total.\n3. Handle the last character outside the loop since there is no subsequent character to compare.\n\n## Implementation:\n\n### Python:\n\n```python\nclass Solution:\n    def romanToInt(self, s: str) -> int:\n        roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        total = 0\n        \n        for i in range(len(s) - 1):\n            if roman[s[i]] < roman[s[i + 1]]:\n                total -= roman[s[i]]\n            else:\n                total += roman[s[i]]\n                \n        total += roman[s[-1]]  # Add the last character\n        return total\n```\n\n### Java:\n\n```java\nclass Solution {\n    public int romanToInt(String s) {\n        Map<Character, Integer> romanMap = new HashMap<>();\n        romanMap.put('I', 1);\n        romanMap.put('V', 5);\n        romanMap.put('X', 10);\n        romanMap.put('L', 50);\n        romanMap.put('C', 100);\n        romanMap.put('D', 500);\n        romanMap.put('M', 1000);\n        \n        int total = 0;\n        \n        for (int i = 0; i < s.length() - 1; i++) {\n            if (romanMap.get(s.charAt(i)) < romanMap.get(s.charAt(i + 1))) {\n                total -= romanMap.get(s.charAt(i));\n            } else {\n                total += romanMap.get(s.charAt(i));\n            }\n        }\n        \n        total += romanMap.get(s.charAt(s.length() - 1));  // Add the last character\n        return total;\n    }\n}\n```\n\n### C++:\n\n```cpp\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        unordered_map<char, int> romanMap = {\n            {'I', 1}, {'V', 5}, {'X', 10}, \n            {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}\n        };\n        \n        int total = 0;\n\n        for (int i = 0; i < s.size() - 1; i++) {\n            if (romanMap[s[i]] < romanMap[s[i + 1]]) {\n                total -= romanMap[s[i]];\n            } else {\n                total += romanMap[s[i]];\n            }\n        }\n\n        total += romanMap[s.back()];  // Add the last character\n        return total;\n    }\n};\n```\n\n### Explanation of the Code:\n1. We initialize our Roman numeral mappings.\n2. We iterate over each character in the string (except the last character).\n3. For each character, we check if it should be added or subtracted based on the next character.\n4. Finally, we add the value of the last character and return the total.\n\nThis method effectively handles the rules of Roman numeral formation and allows for a straightforward conversion. The approach is efficient and reads clearly, making it suitable for implementation in coding interviews."
          },
          {
                    "title": "longest-common-prefix",
                    "solution": "Here’s a clear and concise solution to the \"Longest Common Prefix\" problem using Python, C++, and Java, based on the provided solutions:\n\n### Python Solution\n```python\nclass Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        if not strs:\n            return \"\"\n        # Sort the input strings lexicographically\n        strs.sort()\n        first = strs[0]\n        last = strs[-1]\n        # Compare characters of the first and last string\n        common_prefix = []\n        for i in range(min(len(first), len(last))):\n            if first[i] != last[i]:\n                break\n            common_prefix.append(first[i])\n        return ''.join(common_prefix)\n```\n\n### C++ Solution\n```cpp\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        if (strs.empty()) return \"\";\n        // Sort the strings lexicographically\n        sort(strs.begin(), strs.end());\n        string first = strs[0];\n        string last = strs[strs.size() - 1];\n        // Find common prefix between first and last\n        int i = 0;\n        while (i < first.size() && i < last.size() && first[i] == last[i]) {\n            i++;\n        }\n        return first.substr(0, i);\n    }\n};\n```\n\n### Java Solution\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0) return \"\";\n        // Sort the array of strings\n        Arrays.sort(strs);\n        String first = strs[0];\n        String last = strs[strs.length - 1];\n        // Find common prefix\n        int i = 0;\n        while (i < first.length() && i < last.length() && first.charAt(i) == last.charAt(i)) {\n            i++;\n        }\n        return first.substring(0, i);\n    }\n}\n```\n\n### Explanation\n1. **Sorting the List**: The input strings are sorted to bring similar prefixes next to each other. This allows for efficient comparison of the first and last strings in the sorted list to find the longest common prefix.\n  \n2. **Comparing Characters**: The code iteratively compares characters of the first and last strings, and stops at the first mismatch. The common prefix is then constructed based on these matching characters.\n\n3. **Time Complexity**: The time complexity is O(N log N) due to sorting, followed by O(M) for comparing characters, where N is the number of strings and M is the length of the shortest string.\n\n4. **Edge Cases**: The solution accounts for an empty list of strings and prevents index errors by ensuring comparisons are made only within the bounds of the string lengths.\n\nThis structured approach delivers a clear solution while maintaining efficient performance for the given problem."
          },
          {
                    "title": "3sum",
                    "solution": "Here's a clear and concise solution for the \"Three Sum\" problem based on the user's explanation:\n\n### Problem Statement\nFind all unique triplets in the array which gives the sum of zero.\n\n### Approach\n1. **Sorting**: Start by sorting the input array. This helps in easily skipping duplicates and using the two-pointer technique.\n\n2. **Iterate with Two Pointers**:\n   - Fix one number (the first of the triplet) at index `i`, then use two pointers to find the other two numbers. \n   - The left pointer starts just after `i` (at `i+1`) and the right pointer starts at the end of the array.\n   \n3. **Check Conditions**:\n   - Calculate the sum of the three numbers (fixed number at `i`, number at left pointer, and number at right pointer).\n   - Depending on the sum:\n     - If it's less than zero, increment the left pointer (to get a higher sum).\n     - If it's greater than zero, decrement the right pointer (to get a lower sum).\n     - If it's zero, a triplet is found. Save the triplet and skip any duplicate values by moving the pointers past the duplicates.\n\n4. **Skip Duplicates**: After processing a triplet, skip over any duplicate values of the fixed number and the numbers at the left and right pointers.\n\n5. **Return Results**: Collect all unique triplets in a result vector.\n\n### Implementation (C++ Code)\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end()); // Sort the input array\n        vector<vector<int>> result; // To hold the resulting triplets\n        \n        for (int i = 0; i < nums.size(); ++i) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue; // Skip duplicates for the first number\n            \n            int left = i + 1;\n            int right = nums.size() - 1;\n            \n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                \n                if (sum < 0) {\n                    left++; // We need a larger sum\n                } else if (sum > 0) {\n                    right--; // We need a smaller sum\n                } else {\n                    result.push_back({nums[i], nums[left], nums[right]}); // Found a triplet\n                    \n                    // Skip duplicates\n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n                    \n                    left++; \n                    right--;\n                }\n            }\n        }\n        \n        return result; // Return all unique triplets\n    }\n};\n```\n\n### Complexity Analysis\n- **Time Complexity**: O(n^2), where n is the number of elements in the array. Sorting takes O(n log n) and the two-pointer search takes O(n).\n- **Space Complexity**: O(1) for the pointers, O(n) for storing the output (resulting triplets).\n\nThis solution effectively finds all unique triplets that sum to zero using sorting and a two-pointer technique while ensuring that duplicates are skipped to produce unique results."
          },
          {
                    "title": "letter-combinations-of-a-phone-number",
                    "solution": "Here’s a clear and concise solution to the problem of generating letter combinations from a phone number input. This solution uses an iterative approach:\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    private static final String[] KEYS = {\n        \"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\",\n        \"mno\", \"pqrs\", \"tuv\", \"wxyz\"\n    };\n    \n    public List<String> letterCombinations(String digits) {\n        List<String> result = new ArrayList<>();\n        if (digits.isEmpty()) return result;\n        \n        result.add(\"\"); // Start with an empty string\n\n        for (char digit : digits.toCharArray()) {\n            String letters = KEYS[digit - '0'];\n            List<String> tmp = new ArrayList<>();\n            for (String combination : result) {\n                for (char letter : letters.toCharArray()) {\n                    tmp.add(combination + letter);\n                }\n            }\n            result = tmp; // Move to the next level of combinations\n        }\n        \n        return result;\n    }\n}\n```\n\n### Explanation:\n\n1. **Mapping:** A static array `KEYS` maps each digit to its respective characters like a keypad.\n2. **Initialization:** The result list starts with an empty string to build combinations upon.\n3. **Iteration:** For each digit in the input:\n   - Retrieve the corresponding characters from `KEYS`.\n   - Create a temporary list `tmp` to store new combinations formed by appending the current letters to the existing combinations from the `result`.\n   - Finally, replace `result` with `tmp` for the next iteration.\n4. Once all characters are processed, the `result` contains all possible combinations.\n\nThis method is efficient and straightforward, leveraging iterative processing to expand letter combinations systematically."
          },
          {
                    "title": "remove-nth-node-from-end-of-list",
                    "solution": "To solve the problem of removing the **n**'th node from the end of a singly linked list in a single pass, we can use two pointers: **fast** and **slow**. The main idea is to maintain a gap of **n** nodes between these two pointers. Here is a clear explanation of the process and the corresponding code implementation.\n\n### Approach:\n1. **Initialization**: Start both **fast** and **slow** pointers at the head of the linked list.\n2. **Advance the Fast Pointer**: Move the **fast** pointer **n** steps ahead in the list. This creates a gap of **n** nodes between the **slow** and **fast** pointers.\n3. **Edge Case Check**: If the **fast** pointer reaches the end (i.e., becomes **None**), it means we need to remove the head of the list. In this case, return **head.next**.\n4. **Simultaneous Movement**: Continue moving both pointers until the **fast** pointer reaches the end of the list. At this point, the **slow** pointer will be just before the **n**'th node from the end.\n5. **Remove the Node**: Change the **next** pointer of the **slow** pointer to skip the node to be removed.\n6. **Return the Modified List**: Finally, return the head of the modified list.\n\n### Implementation:\nHere is the code implementation in Python:\n\n```python\nclass Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        fast = slow = head\n        # Advance fast pointer to n positions ahead\n        for _ in range(n):\n            fast = fast.next\n        \n        # If fast is already None, we need to remove the head\n        if not fast:\n            return head.next\n        \n        # Move both pointers until fast reaches the end\n        while fast.next:\n            slow = slow.next\n            fast = fast.next\n        \n        # Remove the n-th node from end\n        slow.next = slow.next.next\n        \n        return head\n```\n\n### Explanation of the Code:\n1. We create two pointers (`fast` and `slow`) both initialized to the `head` of the list.\n2. We move the `fast` pointer `n` steps ahead. If `fast` reaches the end at this step, we directly return `head.next` since we need to remove the head.\n3. We then move both `fast` and `slow` pointers forward until `fast.next` is `None`. This means that `slow` will point to the node just before the one we want to remove.\n4. Finally, we adjust the `next` pointer of the `slow` pointer to skip the node that is to be deleted.\n\n### Time and Space Complexity:\n- **Time Complexity**: \\(O(N)\\), where \\(N\\) is the number of nodes in the linked list. We essentially make one pass through the list.\n- **Space Complexity**: \\(O(1)\\), since we only use a fixed number of pointer variables and do not use any additional data structures that scale with input size.\n\nThis method is efficient and handles all edge cases, including when the head of the list is to be removed."
          },
          {
                    "title": "valid-parentheses",
                    "solution": "Here's a clear and concise solution for the problem of validating parentheses using a stack data structure:\n\n### Intuition\nThe goal is to check if the given string of brackets is valid. A valid string must have all opening brackets matched with corresponding closing brackets in the correct order. We will utilize a stack to help keep track of the opening brackets we encounter.\n\n### Approach\n1. **Initialize a stack**: Create an empty stack to hold opening brackets.\n2. **Iterate through each character** in the given string.\n   - If the character is an opening bracket (`(`, `{`, `[`), push it onto the stack.\n   - If it’s a closing bracket (`)`, `}`, `]`):\n     - Check if the stack is empty. If it is, return `false` (no matching opening bracket).\n     - Otherwise, pop the top of the stack and check if it matches the current closing bracket. If it does not match, return `false`.\n3. **Final check**: After processing all characters, if the stack is empty, return `true` (all brackets matched). If not, return `false`.\n\n### Complexity Analysis\n- **Time Complexity**: O(n), where n is the length of the input string. We traverse the string once, performing constant time operations for each character.\n- **Space Complexity**: O(n), in the worst case where all characters are opening brackets.\n\n### Code Implementation\n\nHere's the concise code implementation in Java:\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>(); // Create an empty stack\n        // Mapping of closing to opening brackets\n        Map<Character, Character> bracketMap = new HashMap<>();\n        bracketMap.put(')', '(');\n        bracketMap.put('}', '{');\n        bracketMap.put(']', '[');\n\n        for (char c : s.toCharArray()) { // Iterate through each character\n            if (bracketMap.containsKey(c)) { // If it's a closing bracket\n                if (stack.isEmpty() || stack.pop() != bracketMap.get(c)) \n                    return false; // Check for match\n            } else {\n                stack.push(c); // It's an opening bracket, push to stack\n            }\n        }\n        return stack.isEmpty(); // Return if all brackets matched\n    }\n}\n```\n\n### Usage\nThis solution can be called with a string argument containing brackets, and it will return a boolean indicating whether the string is valid or not. The implementation supports all types of brackets: parentheses, curly braces, and square brackets."
          },
          {
                    "title": "merge-two-sorted-lists",
                    "solution": "Here is a clear and concise solution to the problem of merging two sorted linked lists, based on the user's submissions:\n\n### Problem Statement\nYou are given the heads of two sorted linked lists, `list1` and `list2`. Merge the two lists into one sorted list. The merged list should be made by splicing together the nodes of the first two lists. \n\n### Approach\n- **Iterative Method**: We use a dummy node to simplify merging. We iterate through both linked lists using two pointers, adding the smaller node to the merged list. When one of the lists is exhausted, we attach the remaining elements of the other list.\n\n- **Recursive Method**: We compare the head nodes of both lists and recursively merge the remaining nodes. If one of the lists is null, we return the other list.\n\n### Complexity\n- **Time Complexity**: O(n + m), where n is the length of list1 and m is the length of list2.\n- **Space Complexity**: O(1) for the iterative version as we only use a constant amount of space, or O(n + m) for the recursive version due to stack space.\n\n### Code Implementation\n\n#### Iterative Approach\n```cpp\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy(0);  // Dummy node to simplify merging\n        ListNode* curr = &dummy; // Pointer to construct the new list\n\n        while (list1 && list2) {\n            if (list1->val < list2->val) {\n                curr->next = list1; // Link to the smaller node\n                list1 = list1->next; // Move to the next node in list1\n            } else {\n                curr->next = list2; // Link to the smaller node\n                list2 = list2->next; // Move to the next node in list2\n            }\n            curr = curr->next; // Move the current pointer forward\n        }\n        \n        curr->next = list1 ? list1 : list2; // Attach the remainder of the non-empty list\n        return dummy.next; // Return the merged list, skipping dummy\n    }\n};\n```\n\n#### Recursive Approach\n```cpp\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n        if (!l1) return l2;  // If l1 is null, return l2\n        if (!l2) return l1;  // If l2 is null, return l1\n\n        if (l1->val < l2->val) {\n            l1->next = mergeTwoLists(l1->next, l2); // Recursively merge the next of l1 and l2\n            return l1; // Return l1 as the new head\n        } else {\n            l2->next = mergeTwoLists(l1, l2->next); // Recursively merge l1 and the next of l2\n            return l2; // Return l2 as the new head\n        }\n    }\n};\n```\n\n### Summary\nBoth approaches efficiently combine two sorted linked lists into one while maintaining sorted order. The choice between iterative and recursive approaches can depend on personal preference and the constraints of the environment."
          },
          {
                    "title": "generate-parentheses",
                    "solution": "Here's a concise solution to the problem of generating valid parentheses given an integer `n`, which represents the number of pairs of parentheses:\n\n### Approach\n1. **Backtracking**: The idea is to use a backtracking algorithm that explores all combinations of valid parentheses.\n2. **Counters**: Maintain two counts: \n   - `left` for the number of `(` used.\n   - `right` for the number of `)` used.\n3. **Constraints**:\n   - You can add `(` if `left < n`.\n   - You can add `)` if `right < left`.\n\n### Python Code\n```python\nfrom typing import List\n\ndef generateParenthesis(n: int) -> List[str]:\n    def backtrack(s='', left=0, right=0):\n        if len(s) == n * 2:\n            results.append(s)\n            return\n        if left < n:\n            backtrack(s + '(', left + 1, right)\n        if right < left:\n            backtrack(s + ')', left, right + 1)\n\n    results = []\n    backtrack()\n    return results\n```\n\n### Java Code\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> results = new ArrayList<>();\n        backtrack(results, \"\", 0, 0, n);\n        return results;\n    }\n\n    private void backtrack(List<String> results, String current, int left, int right, int max) {\n        if (current.length() == max * 2) {\n            results.add(current);\n            return;\n        }\n        if (left < max) {\n            backtrack(results, current + \"(\", left + 1, right, max);\n        }\n        if (right < left) {\n            backtrack(results, current + \")\", left, right + 1, max);\n        }\n    }\n}\n```\n\n### Explanation of the Code\n1. **Function Definition**: The function `generateParenthesis` initializes the results list and calls the backtracking function.\n2. **Backtracking Function**:\n   - If the length of the current string `s` equals `n * 2`, we have a valid combination, which is added to the results list.\n   - It checks the conditions to add a `(` or `)` based on the counts of `left` and `right`.\n3. **Termination**: Recursive calls terminate when a valid combination reaches the required length.\n\nThis solution efficiently explores all potential configurations of valid parentheses while ensuring no invalid configurations are generated."
          },
          {
                    "title": "merge-k-sorted-lists",
                    "solution": "Certainly! Here’s a clear and concise solution for merging k sorted linked lists without using a priority queue. This solution employs a divide-and-conquer approach, similar to merging two lists recursively. \n\n### Java Solution\n\n```java\npublic class Solution {\n    public ListNode mergeKLists(List<ListNode> lists) {\n        if (lists == null || lists.size() == 0) return null;\n        return mergeLists(lists, 0, lists.size() - 1);\n    }\n\n    private ListNode mergeLists(List<ListNode> lists, int left, int right) {\n        if (left == right) {\n            return lists.get(left);\n        }\n        int mid = (left + right) / 2;\n        ListNode l1 = mergeLists(lists, left, mid);\n        ListNode l2 = mergeLists(lists, mid + 1, right);\n        return mergeTwoLists(l1, l2);\n    }\n\n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) return l2;\n        if (l2 == null) return l1;\n\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n\n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            } else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n\n        current.next = l1 != null ? l1 : l2;\n        return dummy.next;\n    }\n}\n```\n\n### Python Solution\n\n```python\nclass Solution(object):\n    def mergeKLists(self, lists):\n        if not lists:\n            return None\n        return self.mergeLists(lists, 0, len(lists) - 1)\n\n    def mergeLists(self, lists, left, right):\n        if left == right:\n            return lists[left]\n        \n        mid = (left + right) // 2\n        l1 = self.mergeLists(lists, left, mid)\n        l2 = self.mergeLists(lists, mid + 1, right)\n        return self.merge(l1, l2)\n\n    def merge(self, l1, l2):\n        dummy = p = ListNode(0)\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                p.next = l1\n                l1 = l1.next\n            else:\n                p.next = l2\n                l2 = l2.next\n            p = p.next\n            \n        p.next = l1 or l2\n        return dummy.next\n```\n\n### Explanation:\n- **Merge Method**: This method merges two sorted linked lists.\n- **Divide and Conquer**: The main method `mergeKLists` divides the list of linked lists into sublists recursively, merging smaller lists into larger sorted lists until only one merged list remains.\n- **Time Complexity**: The algorithm has a time complexity of \\(O(N \\log k)\\), where \\(N\\) is the total number of nodes across all k lists and \\(k\\) is the number of linked lists. \n\nThis approach elegantly avoids the use of priority queues while maintaining efficient merging."
          },
          {
                    "title": "remove-duplicates-from-sorted-array",
                    "solution": "Here's a clear and concise solution to the \"Remove Duplicates from Sorted Array\" problem using the two-pointer technique. The solution efficiently modifies the original array in place to remove duplicates and returns the length of the resulting array.\n\n### Solution Explanation\n\nThe idea is to use two pointers, `i` and `j`:\n- `i` keeps track of the index for unique elements.\n- `j` iterates through the array to find unique elements.\n\nFor each unique element found at index `j`, the code updates the position at `i` and increments `i` for the next unique element. \n\n### Code\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.empty()) return 0; // Handle empty input\n        int i = 0; // Pointer for the unique position\n        for (int j = 1; j < nums.size(); j++) {\n            if (nums[j] != nums[i]) {\n                i++; // Move to the next position\n                nums[i] = nums[j]; // Update the position with the new unique element\n            }\n        }\n        return i + 1; // Length of the array with unique elements\n    }\n};\n```\n\n### Time Complexity\n- O(n): The algorithm goes through the array once.\n\n### Space Complexity\n- O(1): The solution modifies the input array in place with no extra space required.\n\nThis approach is efficient and simple to understand, making it suitable for removing duplicates from a sorted array."
          },
          {
                    "title": "find-the-index-of-the-first-occurrence-in-a-string",
                    "solution": "Here's a clear and concise solution for the problem of finding the first occurrence of a substring (`needle`) in a string (`haystack`) using a sliding window approach:\n\n### Java Solution:\n```java\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        int hLen = haystack.length();\n        int nLen = needle.length();\n        \n        // If needle is empty, return 0\n        if (nLen == 0) return 0;\n\n        // Iterate through all possible starting indices in haystack\n        for (int i = 0; i <= hLen - nLen; i++) {\n            int j = 0;\n            // Check if the substring of haystack matches needle\n            while (j < nLen && haystack.charAt(i + j) == needle.charAt(j)) {\n                j++;\n            }\n            // If we have matched the entire needle\n            if (j == nLen) {\n                return i;\n            }\n        }\n        return -1; // If needle not found in haystack\n    }\n}\n```\n\n### Python Solution:\n```python\nclass Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        hLen = len(haystack)\n        nLen = len(needle)\n\n        if nLen == 0:\n            return 0\n\n        for i in range(hLen - nLen + 1):\n            if haystack[i:i+nLen] == needle:\n                return i\n        return -1\n```\n\n### C++ Solution:\n```cpp\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int hLen = haystack.length();\n        int nLen = needle.length();\n\n        if (nLen == 0) return 0;\n\n        // Iterate over haystack\n        for (int i = 0; i <= hLen - nLen; i++) {\n            int j = 0;\n            // Compare substring\n            while (j < nLen && haystack[i + j] == needle[j]) {\n                j++;\n            }\n            if (j == nLen) {\n                return i; // Found match\n            }\n        }\n        return -1; // Not found\n    }\n};\n```\n\n### Explanation:\n1. **Input Checks**: If the `needle` is an empty string, we return 0 immediately, as per the problem's requirements.\n2. **Iterate through haystack**: Loop through `haystack` while considering valid starting indices for comparisons.\n3. **Character Comparisons**: For each starting position, check if the substring of `haystack` matches `needle`. If all characters match, return the starting index.\n4. **No Match Found**: If the loop completes without finding a match, return -1.\n\n### Time Complexity:\n- The worst-case time complexity is O(N * M), where N is the length of `haystack` and M is the length of `needle`. In the worst case, we might have to check all characters for each starting position.\n\n### Space Complexity:\n- The space complexity is O(1), as we are using only a few additional variables regardless of the input size."
          },
          {
                    "title": "divide-two-integers",
                    "solution": "Here’s a clear and concise solution to the problem of dividing two integers without using the division operator, based on the provided implementations and explanations:\n\n### Problem Statement\nGiven two integers `dividend` and `divisor`, return the quotient when `dividend` is divided by `divisor`. The result should be truncated toward zero, and it should fit within a 32-bit signed integer range. Handle overflow for the input case where `dividend` is `INT_MIN` and `divisor` is `-1`.\n\n### Key Observations\n1. The quotient can be determined by counting how many times the divisor can be subtracted from the dividend.\n2. We can optimize the subtraction process using bit manipulation (left shifting), which effectively doubles the divisor on each iteration.\n3. Care must be taken with the signs of the dividend and divisor to determine the sign of the result.\n4. We must handle overflow for special cases.\n\n### Solution Implementation\nHere is the C++ implementation of the solution:\n\n```cpp\nclass Solution {\npublic:\n    int divide(int dividend, int divisor) {\n        // Handle overflow case\n        if (dividend == INT_MIN && divisor == -1) {\n            return INT_MAX;\n        }\n\n        // Determine the sign of the result\n        long long dvd = labs(dividend);\n        long long dvs = labs(divisor);\n        int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n        long long ans = 0;\n        while (dvd >= dvs) {\n            long long temp = dvs, multiple = 1;\n            while (dvd >= (temp << 1)) {\n                temp <<= 1;\n                multiple <<= 1;\n            }\n            dvd -= temp;\n            ans += multiple;\n        }\n\n        return sign * ans;\n    }\n};\n```\n\n### Explanation\n1. **Overflow Handling**: The function first checks for the overflow scenario where `dividend` is `INT_MIN` and `divisor` is `-1`.\n2. **Sign Determination**: The sign of the result is determined based on whether the dividend and divisor have the same sign.\n3. **Main Loop**: The outer loop continues as long as the dividend is greater than or equal to the divisor.\n   - Inside the loop, we initialize `temp` (the shifted divisor) and `multiple` (the corresponding quotient increment).\n   - An inner loop shifts the divisor to the left until it cannot be subtracted from the dividend anymore.\n   - The dividend is reduced by the largest valid shifted divisor, and the counted multiples are added to the answer.\n4. **Final Result**: The answer is adjusted for the determined sign before returning.\n\nThis solution operates efficiently in `O(log N)` time complexity, where `N` is the value of the dividend, using bitwise operations to optimize the process of finding the quotient."
          },
          {
                    "title": "search-in-rotated-sorted-array",
                    "solution": "Here's a clear and concise solution to the \"Search in Rotated Sorted Array\" problem using binary search. This approach considers that the input array might be rotated and efficiently finds the target value.\n\n### Solution\n\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2; // Avoids potential overflow\n\n            if (nums[mid] == target) {\n                return mid; // Target found\n            }\n\n            // Check if left half is sorted\n            if (nums[left] <= nums[mid]) {\n                // Target is in the left half\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else { // Target is in the right half\n                    left = mid + 1;\n                }\n            } else { // Right half is sorted\n                // Target is in the right half\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else { // Target is in the left half\n                    right = mid - 1;\n                }\n            }\n        }\n        return -1; // Target not found\n    }\n};\n```\n\n### Explanation\n\n1. **Initialization**: We define two pointers, `left` and `right`, pointing to the start and end of the array, respectively.\n2. **Binary Search Loop**: While `left` is less than or equal to `right`, we calculate the middle index `mid`.\n   - If `nums[mid]` is equal to the target, we return the index `mid`.\n3. **Identifying Sorted Half**:\n   - If the left half (`nums[left]` to `nums[mid]`) is sorted:\n     - If the target is within this half, adjust the `right` pointer to `mid - 1`.\n     - If the target is not in this half, adjust the `left` pointer to `mid + 1`.\n   - Otherwise, the right half is sorted:\n     - If the target is within this half, adjust the `left` pointer to `mid + 1`.\n     - If the target is not in this half, adjust the `right` pointer to `mid - 1`.\n4. **Return -1**: If the target is not found after the loop ends, we return `-1`. \n\n### Time Complexity\n- The time complexity is `O(log n)` due to the binary search harnessing the sorted properties of the subarrays.\n\n### Space Complexity\n- The space complexity is `O(1)` as no additional data structures are used apart from variables. \n\nThis implementation is both efficient and straightforward, utilizing the properties of the rotated sorted array effectively."
          },
          {
                    "title": "find-first-and-last-position-of-element-in-sorted-array",
                    "solution": "To solve the problem of finding the starting and ending position of a target value in a sorted array, we can utilize binary search for efficient performance. Below is a clear and concise solution, structured around the concept of two binary searches.\n\n### Problem Summary\nWe're tasked with finding the first and last position of a target value in a sorted array. If the target is not found, we return `[-1, -1]`.\n\n### Approach\nWe'll implement two helper functions:\n1. `findFirst`: This function finds the first occurrence of the target.\n2. `findLast`: This function finds the last occurrence of the target.\n\nBoth functions will utilize the binary search algorithm, which operates in O(log n) time complexity.\n\n### Code Implementation\nHere's a succinct implementation in Python:\n\n```python\nclass Solution:\n    def searchRange(self, nums, target):\n        def findFirst(nums, target):\n            low, high = 0, len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] < target:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return low # the first position where target could be\n        \n        def findLast(nums, target):\n            low, high = 0, len(nums) - 1\n            while low <= high:\n                mid = (low + high) // 2\n                if nums[mid] <= target:\n                    low = mid + 1\n                else:\n                    high = mid - 1\n            return high # the last position where target could be\n        \n        start = findFirst(nums, target)\n        end = findLast(nums, target)\n\n        if start <= end and start < len(nums) and nums[start] == target:\n            return [start, end]\n        return [-1, -1]\n```\n\n### Explanation\n1. **Finding the First Position:**\n   - We search until `low` exceeds `high`.\n   - If `nums[mid]` is less than `target`, we move `low` to `mid + 1`.\n   - Otherwise, we move `high` down to `mid - 1`.\n   - The point at which `low` exits the loop gives us the first position the `target` could occupy, even if it doesn't actually exist in the array.\n\n2. **Finding the Last Position:**\n   - Similar to finding the first position, but we adjust our conditions slightly.\n   - If `nums[mid]` is less than or equal to `target`, we can still look to the right, so we move `low` to `mid + 1`.\n   - When exiting the loop, `high` will point to the last index of the `target`.\n\n3. **Return Values:**\n   - After finding both positions, we check if `start` is less than or equal to `end`, confirming that `target` exists in the array.\n   - If valid, return `[start, end]`; otherwise, return `[-1, -1]`.`\n\n### Complexity\n- **Time Complexity:** O(log n) per function, leading to O(log n) for the overall solution.\n- **Space Complexity:** O(1) since we use only a constant amount of additional space. \n\nThis approach is efficient and elegant, utilizing binary search methods to minimize the number of comparisons made against the target."
          },
          {
                    "title": "valid-sudoku",
                    "solution": "Here's a clear and concise solution to the LeetCode problem of verifying if a given Sudoku board is valid.\n\n```java\npublic class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        boolean[][] rows = new boolean[9][9];\n        boolean[][] cols = new boolean[9][9];\n        boolean[][] boxes = new boolean[3][3][9];\n\n        for (int r = 0; r < 9; r++) {\n            for (int c = 0; c < 9; c++) {\n                char number = board[r][c];\n                if (number != '.') {\n                    int num = number - '1'; // Convert char to index (0-8)\n                    int boxRow = r / 3;\n                    int boxCol = c / 3;\n\n                    // Check for duplicates\n                    if (rows[r][num] || cols[c][num] || boxes[boxRow][boxCol][num]) {\n                        return false;\n                    }\n\n                    // Mark this number as seen\n                    rows[r][num] = true;\n                    cols[c][num] = true;\n                    boxes[boxRow][boxCol][num] = true;\n                }\n            }\n        }\n        return true;\n    }\n}\n```\n\n### Explanation:\n1. **Data Structures**: We use three boolean 2D arrays:\n   - `rows[9][9]`: To check if a number has been used in any row.\n   - `cols[9][9]`: To check if a number has been used in any column.\n   - `boxes[3][3][9]`: To check if a number has been used in any of the 3x3 sub-boxes.\n\n2. **Iteration**: We iterate through each cell in the 9x9 board.\n\n3. **Conversion and Validation**:\n   - For each non-empty cell (`number != '.'`), we convert the character number to its corresponding index (`0-8`).\n   - We compute the box's row and column using integer division for correct box identification.\n   - We check if the number has already been seen in the current row, column, or box. If it has, we return `false`.\n\n4. **Updating State**: If not seen, we mark this number as seen in the respective arrays.\n\n5. **Final Return**: If no duplicates are found throughout the board, the function returns `true`, indicating that the Sudoku board is valid."
          },
          {
                    "title": "count-and-say",
                    "solution": "Here is a clear and concise solution for the \"Count and Say\" problem derived from the user's provided solutions:\n\n```python\ndef countAndSay(n):\n    s = '1'\n    for _ in range(n - 1):\n        temp, count, last_char = '', 0, s[0]\n        for char in s:\n            if char == last_char:\n                count += 1\n            else:\n                temp += str(count) + last_char\n                last_char = char\n                count = 1\n        temp += str(count) + last_char\n        s = temp\n    return s\n```\n\n### Explanation:\n1. **Initialization**: Start with the initial sequence `s` as '1'.\n2. **Loop**: Repeat `n-1` times to generate the next sequence.\n3. **Count Characters**: Use a temporary string (`temp`) to build the next sequence:\n   - Track the count of consecutive characters.\n   - When a different character is encountered, append the count and character to `temp`.\n4. **Update**: Set `s` to the newly formed sequence for the next iteration.\n5. **Return**: Finally, return the nth sequence.\n\nThis solution efficiently counts and constructs the \"count and say\" sequence through iteration and string manipulation."
          },
          {
                    "title": "first-missing-positive",
                    "solution": "Here is a clear and concise solution for the problem of finding the first missing positive integer from an array. The approach described uses constant space and relies on optimally placing the integers within the array:\n\n```python\nclass Solution:\n    def firstMissingPositive(self, nums):\n        n = len(nums)\n        \n        # Step 1: Replace non-positive numbers and numbers larger than n with n + 1\n        for i in range(n):\n            if nums[i] <= 0 or nums[i] > n:\n                nums[i] = n + 1\n        \n        # Step 2: Use the indices as a hash to mark the presence of numbers\n        for i in range(n):\n            num = abs(nums[i])\n            if 1 <= num <= n:\n                nums[num - 1] = -abs(nums[num - 1])  # Mark as found\n        \n        # Step 3: Find the first index that is not marked\n        for i in range(n):\n            if nums[i] > 0:  # If the number is positive, its index + 1 is missing\n                return i + 1\n        \n        # Step 4: If all numbers are present, return n + 1\n        return n + 1\n```\n\n### Explanation of the Code:\n1. **Initialization**: The length of the input array `nums` is stored in `n`.\n2. **Replace Non-Positive or Out of Bounds**: The first loop replaces all numbers that are less than or equal to zero and those greater than `n` with `n + 1`. This is done because the smallest missing positive integer must be in the range `[1, n + 1]`.\n3. **Marking Presence**: The second loop iterates through the list and for each number, if it falls within the range `[1, n]`, it marks its corresponding index as negative to indicate that the number is present in the array.\n4. **Checking for the First Missing Positive**: The third loop checks for the first index `i` where the corresponding value in `nums` is positive, indicating that `i + 1` is the first missing positive number.\n5. **Return Result**: If all numbers from `1` to `n` are present, then it returns `n + 1`.\n\nThis efficient algorithm runs in O(n) time and uses O(1) extra space (not counting the input array)."
          },
          {
                    "title": "trapping-rain-water",
                    "solution": "Here’s a concise and clear solution to the LeetCode problem of trapping rainwater using the two-pointer approach:\n\n```cpp\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int left = 0, right = height.size() - 1;\n        int maxLeft = 0, maxRight = 0;\n        int totalWater = 0;\n\n        while (left < right) {\n            // Calculate water level using the minimum of max heights from both sides\n            if (height[left] < height[right]) {\n                // If current height is greater than or equal to maxLeft, update maxLeft\n                if (height[left] >= maxLeft) {\n                    maxLeft = height[left];\n                } else {\n                    // Else, water can be trapped and added to totalWater\n                    totalWater += maxLeft - height[left];\n                }\n                left++; // Move left pointer to the right\n            } else {\n                // If current height is greater than or equal to maxRight, update maxRight\n                if (height[right] >= maxRight) {\n                    maxRight = height[right];\n                } else {\n                    // Else, water can be trapped and added to totalWater\n                    totalWater += maxRight - height[right];\n                }\n                right--; // Move right pointer to the left\n            }\n        }\n        \n        return totalWater; // Return the total amount of trapped water\n    }\n};\n```\n\n### Explanation:\n1. **Initialization**: We set two pointers, `left` starting from the beginning of the array and `right` from the end. We also initialize `maxLeft` and `maxRight` to record the maximum heights encountered from both sides.\n\n2. **Two-pointer Traversal**: We loop until the `left` pointer is less than the `right` pointer:\n   - Compare the heights at both pointers.\n   - If the height at `left` is less than the height at `right`, we check if it's greater than `maxLeft`. If so, we update `maxLeft`. Otherwise, we calculate how much water can be trapped at `left` and add it to `totalWater`.\n   - If the height at `right` is smaller or equal, we do the same logic but for `maxRight` and the `right` pointer.\n\n3. **Result**: At the end of the loop, we have calculated the total water trapped, which is returned as the result.\n\n### Complexity:\n- **Time Complexity**: O(N), where N is the number of elements in the `height` array.\n- **Space Complexity**: O(1), since we are using a constant amount of space aside from the input."
          },
          {
                    "title": "wildcard-matching",
                    "solution": "Here is a clear and concise solution for the \"Wildcard Matching\" problem (LeetCode 44), summarizing the strategies discussed in various code snippets and explanations you've provided:\n\n### Solution 1: Two-Pointer Technique (Greedy Approach)\n\n```java\npublic class Solution {\n    public boolean isMatch(String s, String p) {\n        int sIndex = 0, pIndex = 0, match = 0, starIndex = -1;\n        while (sIndex < s.length()) {\n            // Character matches or '?'\n            if (pIndex < p.length() && (p.charAt(pIndex) == '?' || s.charAt(sIndex) == p.charAt(pIndex))) {\n                sIndex++;\n                pIndex++;\n            }\n            // '*' found in pattern\n            else if (pIndex < p.length() && p.charAt(pIndex) == '*') {\n                starIndex = pIndex;\n                match = sIndex;\n                pIndex++;\n            }\n            // Last pattern pointer was '*', advance string pointer\n            else if (starIndex != -1) {\n                pIndex = starIndex + 1;\n                match++;\n                sIndex = match;\n            } else {\n                return false; // characters do not match\n            }\n        }\n        // Check for remaining characters in pattern\n        while (pIndex < p.length() && p.charAt(pIndex) == '*') {\n            pIndex++;\n        }\n        return pIndex == p.length();\n    }\n}\n```\n\n### Solution 2: Dynamic Programming\n\nThis approach utilizes a 2D DP table to solve the problem with a space complexity of O(m*n), where m is the length of the string and n is the length of the pattern.\n\n```java\npublic class Solution {\n    public boolean isMatch(String s, String p) {\n        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];\n        dp[0][0] = true;\n\n        // Pre-fill DP table for patterns starting with '*' \n        for (int j = 1; j <= p.length(); j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 1];\n            }\n        }\n\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 1; j <= p.length(); j++) {\n                if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '?') {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (p.charAt(j - 1) == '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                }\n            }\n        }\n        return dp[s.length()][p.length()];\n    }\n}\n```\n\n### Solution 3: 1D DP Optimization\n\nYou can also optimize the memory usage to O(n) by using a single array.\n\n```java\npublic class Solution {\n    public boolean isMatch(String s, String p) {\n        boolean[] dp = new boolean[p.length() + 1];\n        dp[0] = true;\n\n        for (int j = 1; j <= p.length(); j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[j] = dp[j - 1];\n            }\n        }\n\n        for (int i = 1; i <= s.length(); i++) {\n            boolean[] newDp = new boolean[p.length() + 1];\n            for (int j = 1; j <= p.length(); j++) {\n                if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '?') {\n                    newDp[j] = dp[j - 1];\n                } else if (p.charAt(j - 1) == '*') {\n                    newDp[j] = dp[j] || newDp[j - 1];\n                }\n            }\n            dp = newDp;\n        }\n        return dp[p.length()];\n    }\n}\n```\n\n### Key Concepts\n\n1. **Two-Pointer Technique:** This is effective for problems involving matching strings with patterns using wildcards. It effectively manages the states of both the string and the pattern without additional space.\n  \n2. **Dynamic Programming:** This method systematically builds up solutions to subproblems (matching substrings and subpatterns) and uses them to solve larger problems. Careful initialization of the DP table is critical for edge cases, especially when dealing with leading `*` characters.\n\n3. **1D Array Optimization:** Reducing the space complexity from O(m*n) to O(n) by leveraging the fact that the state transitions in DP rely on the previous row only.\n\nChoose the solution based on your preference for simplicity or efficiency of space. The greedy solution is straightforward and easy to understand, while the dynamic programming solution provides a structured way to approach the problem systematically."
          },
          {
                    "title": "permutations",
                    "solution": "Here’s a clear and concise version of your provided solutions for commonly encountered backtracking problems on LeetCode, specifically focusing on subsets, permutations, combination sums, and palindrome partitioning.\n\n### 1. Subsets\n\n**Problem:** [Subsets](https://leetcode.com/problems/subsets/)\n```java\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrack(result, new ArrayList<>(), nums, 0);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, int start) {\n    result.add(new ArrayList<>(tempList));\n    for (int i = start; i < nums.length; i++) {\n        tempList.add(nums[i]);\n        backtrack(result, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}\n```\n\n### 2. Subsets II (Duplicates)\n\n**Problem:** [Subsets II](https://leetcode.com/problems/subsets-ii/)\n```java\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(result, new ArrayList<>(), nums, 0);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, int start) {\n    result.add(new ArrayList<>(tempList));\n    for (int i = start; i < nums.length; i++) {\n        if (i > start && nums[i] == nums[i - 1]) continue; // skip duplicates\n        tempList.add(nums[i]);\n        backtrack(result, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}\n```\n\n### 3. Permutations\n\n**Problem:** [Permutations](https://leetcode.com/problems/permutations/)\n```java\npublic List<List<Integer>> permute(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrack(result, new ArrayList<>(), nums);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums) {\n    if (tempList.size() == nums.length) {\n        result.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = 0; i < nums.length; i++) {\n            if (tempList.contains(nums[i])) continue; // skip if already exists\n            tempList.add(nums[i]);\n            backtrack(result, tempList, nums);\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n```\n\n### 4. Permutations II (Duplicates)\n\n**Problem:** [Permutations II](https://leetcode.com/problems/permutations-ii/)\n```java\npublic List<List<Integer>> permuteUnique(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n    backtrack(result, new ArrayList<>(), nums, new boolean[nums.length]);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, boolean[] used) {\n    if (tempList.size() == nums.length) {\n        result.add(new ArrayList<>(tempList));\n    } else {\n        for (int i = 0; i < nums.length; i++) {\n            if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) continue;\n            used[i] = true;\n            tempList.add(nums[i]);\n            backtrack(result, tempList, nums, used);\n            used[i] = false;\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n```\n\n### 5. Combination Sum\n\n**Problem:** [Combination Sum](https://leetcode.com/problems/combination-sum/)\n```java\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrack(result, new ArrayList<>(), candidates, target, 0);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, int remain, int start) {\n    if (remain < 0) return;\n    else if (remain == 0) result.add(new ArrayList<>(tempList));\n    else {\n        for (int i = start; i < nums.length; i++) {\n            tempList.add(nums[i]);\n            backtrack(result, tempList, nums, remain - nums[i], i); // allow the same element to be reused\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n```\n\n### 6. Combination Sum II (No Reuse)\n\n**Problem:** [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\n```java\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(candidates);\n    backtrack(result, new ArrayList<>(), candidates, target, 0);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, int remain, int start) {\n    if (remain < 0) return;\n    else if (remain == 0) result.add(new ArrayList<>(tempList));\n    else {\n        for (int i = start; i < nums.length; i++) {\n            if (i > start && nums[i] == nums[i - 1]) continue; // skip duplicates\n            tempList.add(nums[i]);\n            backtrack(result, tempList, nums, remain - nums[i], i + 1);\n            tempList.remove(tempList.size() - 1);\n        }\n    }\n}\n```\n\n### 7. Palindrome Partitioning\n\n**Problem:** [Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/)\n```java\npublic List<List<String>> partition(String s) {\n    List<List<String>> result = new ArrayList<>();\n    backtrack(result, new ArrayList<>(), s, 0);\n    return result;\n}\n\nprivate void backtrack(List<List<String>> result, List<String> tempList, String s, int start) {\n    if (start == s.length()) {\n        result.add(new ArrayList<>(tempList));\n    } else {\n        for (int end = start; end < s.length(); end++) {\n            if (isPalindrome(s, start, end)) {\n                tempList.add(s.substring(start, end + 1));\n                backtrack(result, tempList, s, end + 1);\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n}\n\nprivate boolean isPalindrome(String s, int low, int high) {\n    while (low < high) {\n        if (s.charAt(low++) != s.charAt(high--)) return false;\n    }\n    return true;\n}\n```\n\nThese code snippets provide clear implementations of several common backtracking problems, encapsulating the logic used to generate combinations, permutations, and partitions of a set or string. Each function is intended to be straightforward while demonstrating fundamental backtracking techniques."
          },
          {
                    "title": "rotate-image",
                    "solution": "To solve the problem of rotating a matrix (2D array) by 90 degrees clockwise or anticlockwise, we can follow a consistent method involving two main steps: transposing the matrix and then reversing the rows or columns. Here's a concise explanation of both clockwise and anticlockwise rotation, along with the corresponding code solutions.\n\n### Clockwise Rotation (90 degrees)\n\n1. **Transpose the Matrix**: Swap rows with columns. For any element at position `(i, j)`, move it to `(j, i)`.\n2. **Reverse each Row**: Reverse each row of the transposed matrix to achieve the final rotated matrix.\n\n**Code Example:**\n```cpp\nvoid rotate(vector<vector<int>>& matrix) {\n    int n = matrix.size();\n    \n    // Transpose the matrix\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            swap(matrix[i][j], matrix[j][i]);\n        }\n    }\n    \n    // Reverse each row\n    for (int i = 0; i < n; ++i) {\n        reverse(matrix[i].begin(), matrix[i].end());\n    }\n}\n```\n\n### Anticlockwise Rotation (90 degrees)\n\n1. **Transpose the Matrix**: This step remains the same as the clockwise rotation.\n2. **Reverse each Column**: Instead of reversing rows, we reverse each column of the transposed matrix.\n\n**Code Example:**\n```cpp\nvoid anti_rotate(vector<vector<int>>& matrix) {\n    int n = matrix.size();\n    \n    // Transpose the matrix\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            swap(matrix[i][j], matrix[j][i]);\n        }\n    }\n    \n    // Reverse each column\n    for (int j = 0; j < n; ++j) {\n        for (int i = 0; i < n / 2; ++i) {\n            swap(matrix[i][j], matrix[n - 1 - i][j]);\n        }\n    }\n}\n```\n\n### Explanation of Steps:\n- **Transpose**: This changes rows to columns and effectively prepares the matrix for rotation.\n- **Reversal**: The reversal is crucial as it adjusts the positions of the elements after transposing to achieve the required rotation.\n\nThis method is efficient and maintains the space complexity of O(1) for in-place rotations, ensuring that no additional matrices are used. The time complexity is O(n^2), where n is the dimension of the matrix since every element needs to be accessed and moved."
          },
          {
                    "title": "group-anagrams",
                    "solution": "Here is a clear and concise solution for the problem of grouping anagrams:\n\n## Problem Statement\nGiven an array of strings, group the strings into anagrams. An anagram is a word formed by rearranging the letters of a different word.\n\n## Approach\n1. **Use a Hash Map**: Use an unordered map (or dictionary) to group words by their sorted character representation.\n2. **Sort Each Word**: For each word, sort its characters to get a key that represents its anagram group. \n3. **Store Original Words**: Map the sorted key to a list of original words that correspond to that key.\n\n## Implementation\n\n### C++\n```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> mp;\n        for (const string& s : strs) {\n            string sortedStr = s; \n            sort(sortedStr.begin(), sortedStr.end());\n            mp[sortedStr].push_back(s);\n        }\n        \n        vector<vector<string>> ans;\n        for (auto& pair : mp) {\n            ans.push_back(pair.second);\n        }\n        \n        return ans;\n    }\n};\n```\n\n### Java\n```java\nimport java.util.*;\n\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<>();\n        \n        for (String s : strs) {\n            char[] chars = s.toCharArray();\n            Arrays.sort(chars);\n            String sortedString = new String(chars);\n            \n            map.computeIfAbsent(sortedString, k -> new ArrayList<>()).add(s);\n        }\n        \n        return new ArrayList<>(map.values());\n    }\n}\n```\n\n### Python\n```python\nfrom collections import defaultdict\n\nclass Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        anagram_map = defaultdict(list)\n        \n        for word in strs:\n            sorted_word = ''.join(sorted(word))\n            anagram_map[sorted_word].append(word)\n        \n        return list(anagram_map.values())\n```\n\n## Explanation of the Code\n1. **Data Structure**: An unordered map or dictionary is used to group the words.\n2. **Sorting**: For each word, sort its characters. This provides a common key for all its anagrams.\n3. **Grouping**: Insert the original word into the list corresponding to its sorted key in the map.\n4. **Collecting Results**: Finally, extract the grouped anagrams from the map and return them as a list.\n\nThis approach effectively groups anagrams with a time complexity of O(N * K log K), where:\n- N is the number of words,\n- K is the maximum length of a word."
          },
          {
                    "title": "powx-n",
                    "solution": "To solve the problem of calculating \\( x^n \\) efficiently, we can use the method of Binary Exponentiation. This approach reduces the time complexity from \\( O(n) \\) to \\( O(\\log n) \\) by utilizing the binary representation of the exponent \\( n \\).\n\n### Clear Solution:\n\n1. **Understanding the Problem**:\n   - We need to compute \\( x^n \\), where \\( x \\) is a double and \\( n \\) is an integer.\n   - Directly multiplying \\( x \\) by itself \\( n \\) times would be inefficient, especially for large \\( n \\).\n\n2. **Binary Exponentiation Approach**:\n   - The algorithm takes advantage of the properties of exponents: \n     - \\( x^n = x^{n/2} \\times x^{n/2} \\) if \\( n \\) is even.\n     - \\( x^n = x \\times x^{n-1} \\) if \\( n \\) is odd.\n   - This means we can square the base \\( x \\) and halve the exponent \\( n \\) recursively or iteratively.\n\n3. **Handling Negative Exponents**:\n   - If \\( n \\) is negative, we can convert the problem to \\( x^{-n} \\) and return \\( 1/x^{|n|} \\).\n\n4. **Iterative Implementation**:\n   We can implement this approach iteratively for better performance and to avoid issues with recursion limits.\n\n### Implementation in Java:\n\n```java\npublic class Solution {\n    public double myPow(double x, int n) {\n        if (n == 0) return 1; // Base case: any number to the power of 0 is 1\n        if (n < 0) { // Handle negative exponent\n            x = 1 / x;\n            n = -n; // Make n positive\n        }\n        \n        double result = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) { // If n is odd\n                result *= x; // Multiply result with current x\n            }\n            x *= x; // Square the base for the next iteration\n            n >>= 1; // Divide n by 2\n        }\n        \n        return result;\n    }\n}\n```\n\n### Explanation of the Code:\n- **Initialization**: Start with `result = 1`. The variable `x` is adjusted in case of negative `n`.\n- **Loop**: While `n` is greater than 0:\n  - If `n` is odd (checked using `n & 1`), multiply `result` by `x`.\n  - Square `x` for the next iteration.\n  - Divide `n` by 2 using right shift `n >>= 1`.\n- **Return**: Finally, return the computed result.\n\n### Complexity Analysis:\n- **Time Complexity**: \\( O(\\log n) \\), as we are halving the exponent each iteration.\n- **Space Complexity**: \\( O(1) \\), since we are using a constant amount of space.\n\nThis optimized approach efficiently computes large powers without running into performance issues."
          },
          {
                    "title": "maximum-subarray",
                    "solution": "Here is a concise solution to the problem of finding the maximum sum of a contiguous subarray in an array `nums`, utilizing Kadane's Algorithm:\n\n### Solution Explanation:\n\nThe algorithm maintains two variables: `maxSoFar` (the maximum sum encountered so far) and `maxEndingHere` (the maximum sum of the subarray ending at the current index). As we iterate through each element in `nums`, we update `maxEndingHere` by either adding the current element to it or starting fresh from the current element if `maxEndingHere` becomes negative. We then update `maxSoFar` to ensure it holds the maximum value found.\n\n### Code Implementation:\n\n**Java**:\n```java\npublic class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxSoFar = nums[0];\n        int maxEndingHere = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n\n        return maxSoFar;\n    }\n}\n```\n\n**Python**:\n```python\nclass Solution:\n    def maxSubArray(self, nums):\n        max_so_far = nums[0]\n        max_ending_here = nums[0]\n\n        for i in range(1, len(nums)):\n            max_ending_here = max(max_ending_here + nums[i], nums[i])\n            max_so_far = max(max_so_far, max_ending_here)\n\n        return max_so_far\n```\n\n### Time Complexity:\n- **O(N)**: Each element is processed once.\n\n### Space Complexity:\n- **O(1)**: Only a constant amount of extra space is used for the variables `maxSoFar` and `maxEndingHere`.\n\n### Notes:\n- The algorithm works even for cases where all elements are negative, as it will return the least negative element in the array.\n- Make sure to analyze and dry run the algorithm for various scenarios to understand its robustness."
          },
          {
                    "title": "spiral-matrix",
                    "solution": "Here’s a clear and concise solution for the problem of returning the elements of a matrix in spiral order. The approach involves iteratively traversing the matrix while adjusting the boundaries until all elements are visited.\n\n### Python Solution:\n\n```python\ndef spiralOrder(matrix):\n    if not matrix:\n        return []\n    \n    res = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n\n    while top <= bottom and left <= right:\n        # Traverse right\n        for j in range(left, right + 1):\n            res.append(matrix[top][j])\n        top += 1\n\n        # Traverse down\n        for i in range(top, bottom + 1):\n            res.append(matrix[i][right])\n        right -= 1\n\n        if top <= bottom:\n            # Traverse left\n            for j in range(right, left - 1, -1):\n                res.append(matrix[bottom][j])\n            bottom -= 1\n\n        if left <= right:\n            # Traverse up\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n\n    return res\n```\n\n### Explanation:\n1. **Initialization**: Check if the matrix is empty; if yes, return an empty list. Define the boundaries `top`, `bottom`, `left`, and `right`.\n\n2. **Loop through the matrix**:\n    - Traverse from left to right along the `top` boundary, then increment `top`.\n    - Traverse from top to bottom along the `right` boundary, then decrement `right`.\n    - If there are rows remaining (`top` ≤ `bottom`), traverse from right to left along the `bottom` boundary, then decrement `bottom`.\n    - If there are columns remaining (`left` ≤ `right`), traverse from bottom to top along the `left` boundary, then increment `left`.\n\n3. **Repeat** the process until all elements are traversed.\n\n### Time Complexity:\n- O(m * n), where m is the number of rows and n is the number of columns in the matrix.\n\n### Space Complexity:\n- O(1) for the traversal, but O(m * n) is used for storing the output.\n\nThis solution efficiently handles the traversal of the matrix in a spiral order, making adjustments after each complete round of traversals."
          },
          {
                    "title": "jump-game",
                    "solution": "Here’s a concise and clear solution for the \"Jump Game\" problem from LeetCode, integrating the various approaches discussed. \n\n## Problem Statement\nGiven an array of non-negative integers, where each element represents the maximum jump length at that position, determine if you can reach the last index starting from the first index.\n\n## Solution\nWe'll use a greedy approach to determine the maximum index we can reach as we iterate through the array. If at any point the current index exceeds the maximum reachable index, return false. If we successfully iterate through the array, return true.\n\n### Code\n```cpp\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int maxReach = 0; // Maximum index we can reach so far\n        for (int i = 0; i < nums.size(); i++) {\n            if (i > maxReach) return false; // If the current index is beyond reach\n            maxReach = max(maxReach, i + nums[i]); // Update the maximum reach\n        }\n        return true; // We can reach the last index\n    }\n};\n```\n\n### Python Version\nHere is the equivalent solution in Python using the same greedy approach:\n\n```python\nclass Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        maxReach = 0\n        for i in range(len(nums)):\n            if i > maxReach: \n                return False\n            maxReach = max(maxReach, i + nums[i])\n        return True\n```\n\n## Complexity Analysis\n- **Time Complexity:** \\(O(n)\\) where \\(n\\) is the length of the input array. We make a single pass through the array.\n- **Space Complexity:** \\(O(1)\\) since we only use a fixed amount of extra space for the `maxReach` variable.\n\nThe greedy approach is efficient and avoids the overhead of recursive solutions or iterative dynamic programming, making it optimal for this problem."
          },
          {
                    "title": "merge-intervals",
                    "solution": "Here's a clear and concise solution to the problem of merging overlapping intervals based on the provided code snippets:\n\n### Algorithm Overview\n\n1. **Sort the Intervals**: First, sort the intervals based on their starting points.\n2. **Merge Overlapping Intervals**: Iterate through the sorted intervals and merge them if they overlap.\n3. **Store the Result**: When you encounter a non-overlapping interval, add the merged interval to the result list.\n\n### Solution in Python\n\n```python\nclass Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        # Sort the intervals based on the starting point\n        intervals.sort(key=lambda x: x[0])\n        \n        result = []\n        \n        for interval in intervals:\n            # If result is empty or current interval does not overlap with last one in result\n            if not result or result[-1][1] < interval[0]:\n                result.append(interval)  # Add the interval to result\n            else:\n                # Overlapping intervals, merge them\n                result[-1][1] = max(result[-1][1], interval[1])\n        \n        return result\n```\n\n### Solution in C++\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        if (intervals.size() <= 1) return intervals; // If there's only one or no interval\n        \n        // Sort intervals based on the starting point\n        sort(intervals.begin(), intervals.end());\n\n        vector<vector<int>> output;\n        output.push_back(intervals[0]); // Add the first interval to the result\n        \n        for (int i = 1; i < intervals.size(); i++) {\n            // Check if there is an overlap\n            if (output.back()[1] >= intervals[i][0]) {\n                // Merge overlapping intervals\n                output.back()[1] = max(output.back()[1], intervals[i][1]);\n            } else {\n                // No overlap, add the current interval\n                output.push_back(intervals[i]);\n            }\n        }\n\n        return output;\n    }\n};\n```\n\n### Solution in Java\n\n```java\nclass Solution {\n    public int[][] merge(int[][] intervals) {\n        if (intervals.length <= 1) return intervals;\n\n        // Sort intervals based on the starting point\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n\n        List<int[]> result = new ArrayList<>();\n        result.add(intervals[0]); // Add the first interval to the result\n\n        for (int[] interval : intervals) {\n            // Check if there is an overlap\n            if (result.get(result.size() - 1)[1] >= interval[0]) {\n                // Merge overlapping intervals\n                result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], interval[1]);\n            } else {\n                // No overlap, add the current interval\n                result.add(interval);\n            }\n        }\n\n        return result.toArray(new int[result.size()][]);\n    }\n}\n```\n\n### Key Points\n\n- **Time Complexity**: O(n log n) due to sorting, where n is the number of intervals.\n- **Space Complexity**: O(n) for storing the result.\n- This approach efficiently merges intervals and handles various cases (including single intervals and completely overlapping intervals)."
          },
          {
                    "title": "unique-paths",
                    "solution": "Here’s a consolidated solution to the unique paths problem on a grid using a combinatorial approach, dynamic programming, memoization, and the binomial coefficient method:\n\n### Problem Summary\nYou are given a grid of size `m x n` and you need to find the total number of unique paths from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)`. The robot can only move down or right.\n\n### Combinatorial Approach\nThe total number of unique paths can be calculated using combinatorial mathematics. To reach from `(0, 0)` to `(m-1, n-1)`, the robot must make `(m-1)` down moves and `(n-1)` right moves. Thus, the total moves required are `(m-1) + (n-1) = m + n - 2`.\n\nThe number of unique paths can be computed as:\n\\[ \\text{Unique Paths} = \\frac{(m+n-2)!}{(m-1)!(n-1)!} \\]\n\nHere is how to implement this in code:\n\n**C++**\n```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        long ans = 1;\n        for (int i = 1; i < n; i++) { // Choose the smaller n to minimize computations\n            ans = ans * (m + i - 1) / i;\n        }\n        return ans;\n    }\n};\n```\n\n**Python**\n```python\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        res = 1\n        for i in range(1, n):\n            res = res * (m + i - 1) // i\n        return res\n```\n\n### Dynamic Programming Approach\nUsing a dynamic programming matrix, we can compute the paths iteratively.\n\n**C++**\n```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector<int>(n, 1));\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        \n        return dp[m - 1][n - 1];\n    }\n};\n```\n\n**Python**\n```python\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1] * n for _ in range(m)]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        \n        return dp[m - 1][n - 1]\n```\n\n### Optimized Space Approach\nSince we only need the previous row and current row, we can optimize space to `O(n)` instead of `O(m*n)`.\n\n**C++**\n```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> dp(n, 1);\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[j] += dp[j - 1];\n            }\n        }\n        \n        return dp[n - 1];\n    }\n};\n```\n\n**Python**\n```python\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [1] * n\n        \n        for _ in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j - 1]\n        \n        return dp[-1]\n```\n\n### Conclusion\nYou can solve the unique paths problem using different methods: combinatorial logic, dynamic programming, and space-optimized techniques. Each method has its pros and cons regarding readability, performance, and complexity, but all yield the correct number of unique paths from the start to the destination in the grid."
          },
          {
                    "title": "plus-one",
                    "solution": "Here is a clear and concise solution for the \"Plus One\" problem based on the provided user's solutions:\n\n```java\npublic int[] plusOne(int[] digits) {\n    int n = digits.length;\n\n    // Traverse the digits array from the last element.\n    for (int i = n - 1; i >= 0; i--) {\n        // If the current digit is less than 9, just increment and return the array.\n        if (digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        // If the current digit is 9, set it to 0 (due to carry).\n        digits[i] = 0;\n    }\n\n    // If all the digits were 9, we need a new array of size n + 1.\n    int[] newNumber = new int[n + 1];\n    newNumber[0] = 1; // Set the first digit to 1.\n\n    return newNumber; // Return the new array.\n}\n```\n\n### Explanation:\n1. **Initialization**: The method starts by determining the length of the input array `digits`.\n   \n2. **Reverse Traversal**: It iterates through the array from the last digit to the first.\n   - If the current digit is less than 9, it increments that digit and returns the modified array.\n   - If the digit is 9, it sets it to 0, as a carry-over will occur.\n\n3. **Handling Overflow**: If the loop completes and all digits are set to 0 (which means they were all 9), a new array of size `n + 1` is created. The most significant digit (at index 0) is set to 1, while the rest are automatically 0 due to initialization.\n\n4. **Return Result**: Finally, it returns the new or modified array. \n\n### Time Complexity:\n- O(n): where n is the length of the input array, as we may need to iterate through each digit once.\n\n### Space Complexity:\n- O(n): In a worst-case scenario (all digits being 9), we create a new array of size `n + 1`.\n\nThis solution efficiently handles the \"Plus One\" scenario, even for cases with multiple carries."
          },
          {
                    "title": "sqrtx",
                    "solution": "# Square Root Calculation Using Binary Search\n\n## Intuition\nTo find the square root of a non-negative integer x, we can employ a binary search approach. This method efficiently narrows down the possible values for the square root without the need for iterative subtraction or using a library function.\n\n## Approach\n1. **Handle Special Cases**: If \\( x \\) is 0 or 1, return \\( x \\) as the square root since \\( \\sqrt{0} = 0 \\) and \\( \\sqrt{1} = 1 \\).\n   \n2. **Initialize the Search Range**: Set up two pointers, `start` at 1 and `end` at \\( x \\).\n   \n3. **Binary Search Loop**:\n   - While `start` is less than or equal to `end`:\n     - Compute the middle value `mid` using `mid = start + (end - start) // 2`. This prevents potential overflow.\n     - If the square of `mid` is equal to \\( x \\), return `mid` (we found the exact square root).\n     - If the square of `mid` is greater than \\( x \\), move the `end` pointer to `mid - 1` to search in the lower half.\n     - If the square of `mid` is less than \\( x \\), move the `start` pointer to `mid + 1` to search in the upper half.\n     \n4. **Return the Largest Integer Less Than or Equal to the Square Root**: When the loop exits, `end` will hold the floor value of the square root. Thus, we return `end`.\n\n## Complexity\n- **Time Complexity**: \\( O(\\log N) \\) due to the halving of the search space with each iteration.\n- **Space Complexity**: \\( O(1) \\) as we use a constant amount of space.\n\n## Code Implementations\n\n### Java\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        if (x == 0 || x == 1) return x;\n        int start = 1, end = x;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if ((long) mid * mid > (long) x)\n                end = mid - 1;\n            else if (mid * mid == x)\n                return mid;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n}\n```\n\n### C++\n```cpp\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0 || x == 1) return x;\n        int start = 1, end = x;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (static_cast<long long>(mid) * mid > x)\n                end = mid - 1;\n            else if (mid * mid == x)\n                return mid;\n            else\n                start = mid + 1;\n        }\n        return end;\n    }\n};\n```\n\n### Python\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 0 or x == 1:\n            return x\n        start, end = 1, x\n        while start <= end:\n            mid = start + (end - start) // 2\n            if mid * mid > x:\n                end = mid - 1\n            elif mid * mid == x:\n                return mid\n            else:\n                start = mid + 1\n        return end\n```\n\n### JavaScript\n```javascript\nvar mySqrt = function(x) {\n    if (x === 0 || x === 1) return x;\n    let start = 1, end = x;\n    while (start <= end) {\n        let mid = start + Math.floor((end - start) / 2);\n        if (mid * mid > x) {\n            end = mid - 1;\n        } else if (mid * mid === x) {\n            return mid;\n        } else {\n            start = mid + 1;\n        }\n    }\n    return end;\n};\n```\n\nThis concise implementation ensures that we find the square root efficiently while handling potential edge cases seamlessly."
          },
          {
                    "title": "climbing-stairs",
                    "solution": "The task is to solve the problem of counting the number of distinct ways to climb a staircase with `n` steps, where you can take either 1 or 2 steps at a time. This is a classic dynamic programming problem, and the intuition behind the solution is similar to the Fibonacci sequence.\n\nHere's a clear and concise solution using the space-optimized approach:\n\n### Solution Outline:\n1. **Base Cases**:\n   - If `n == 0`, there are `0` ways to climb the stairs.\n   - If `n == 1`, there is `1` way (one single step).\n   - If `n == 2`, there are `2` ways (either two single steps or one double step).\n\n2. **Recurrence Relation**:\n   - For `n > 2`, the number of ways to climb to the nth step can be calculated as the sum of the ways to climb to the (n-1)th and (n-2)th steps:\n     \\[\n     \\text{ways}(n) = \\text{ways}(n-1) + \\text{ways}(n-2)\n     \\]\n\n### Python Implementation:\n\n```python\nclass Solution:\n    def climbStairs(self, n: int) -> int:\n        # Base cases\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        # Space optimized solution\n        prev2, prev1 = 1, 2  # Represents ways(n-2) and ways(n-1)\n        \n        for i in range(3, n + 1):\n            current = prev1 + prev2  # Calculate current ways\n            prev2, prev1 = prev1, current  # Update for the next iteration\n            \n        return prev1  # This holds the number of ways to climb `n` stairs\n```\n\n### Explanation:\n- We start by checking for base cases for `n`, returning the respective values.\n- For `n > 2`, we maintain two variables `prev1` and `prev2` which store the number of ways to reach the last two steps, respectively.\n- In each iteration, we calculate the current number of ways to reach the `i`th step as the sum of the previous two values.\n- The loop continues until we compute the value for the `n`th step, which is returned.\n\n### Complexity:\n- **Time Complexity**: \\( O(n) \\), since we iterate up to `n`.\n- **Space Complexity**: \\( O(1) \\), only a constant amount of space is used (for `prev1`, `prev2`, and `current`). \n\nBy following this approach, we efficiently compute the total distinct ways to climb the stairs while minimizing space complexity."
          },
          {
                    "title": "set-matrix-zeroes",
                    "solution": "Here’s a clear and concise solution for the \"Set Matrix Zeroes\" problem based on the provided information:\n\n## Problem:\nGiven an m x n integer matrix, if an element is 0, set its entire row and column to 0. Do it in place.\n\n## Approach:\n1. Use the first row and first column of the matrix as indicators. The `matrix[0][0]` will serve as a flag for the first row and a separate boolean variable (`col0`) for the first column.\n2. First, traverse the matrix to identify whether the first row and first column should be set to zero, and use the first row and column to mark the rows and columns that need to be zeroed.\n3. Next, iterate through the matrix (excluding the first row and column) and set elements to zero based on the marker conditions set in the first row and column.\n4. Finally, set the first row and first column based on the flags.\n\n## Code:\n```java\npublic class Solution {\n    public void setZeroes(int[][] matrix) {\n        boolean fr = false, fc = false; // flags for first row and column\n\n        // Check if first row should be set to zero\n        for (int j = 0; j < matrix[0].length; j++) {\n            if (matrix[0][j] == 0) {\n                fr = true;\n                break;\n            }\n        }\n        \n        // Check if first column should be set to zero\n        for (int i = 0; i < matrix.length; i++) {\n            if (matrix[i][0] == 0) {\n                fc = true;\n                break;\n            }\n        }\n\n        // Use first row and column to mark zeroes for rest of the matrix\n        for (int i = 1; i < matrix.length; i++) {\n            for (int j = 1; j < matrix[0].length; j++) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0; // Mark this row to be zeroed\n                    matrix[0][j] = 0; // Mark this column to be zeroed\n                }\n            }\n        }\n\n        // Zero out cells based on marks\n        for (int i = 1; i < matrix.length; i++) {\n            for (int j = 1; j < matrix[0].length; j++) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n\n        // Zero out the first row if needed\n        if (fr) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                matrix[0][j] = 0;\n            }\n        }\n\n        // Zero out the first column if needed\n        if (fc) {\n            for (int i = 0; i < matrix.length; i++) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n}\n```\n\n## Complexity:\n- **Time Complexity:** O(m * n), where m is the number of rows and n is the number of columns. This results from iterating through the matrix a constant number of times.\n- **Space Complexity:** O(1), as we are modifying the matrix in place without using any additional space except for constant variables.\n\nThis solution effectively utilizes the matrix itself as storage for the state information while maintaining efficiency in both time and space."
          },
          {
                    "title": "sort-colors",
                    "solution": "Here's a refined and concise solution to the Dutch National Flag problem (Sorting Colors) based on the provided user solutions:\n\n### Problem Statement\nYou are given an array containing integers representing colors—0 for red, 1 for white, and 2 for blue. The objective is to sort the array in such a way that all 0s come first, followed by all 1s, and finally all 2s, in a single pass (O(n) time complexity) and using constant space (O(1) space complexity).\n\n### Solution Approach\nWe will use the Dutch National Flag algorithm, which involves maintaining three pointers:\n- `low`: Tracks the position where the next 0 should go.\n- `mid`: Represents the current position being evaluated.\n- `high`: Tracks the position where the next 2 should go.\n\nWe will iterate over the array and perform the following actions based on the value at `mid`:\n- If `nums[mid] == 0`, swap it with `nums[low]`, then increment both `low` and `mid`.\n- If `nums[mid] == 1`, just increment `mid`.\n- If `nums[mid] == 2`, swap it with `nums[high]` and decrement `high` (do not increment `mid` since we need to evaluate the element swapped from `high`).\n\n### Implementation\nHere is the Python implementation of the above approach:\n\n```python\nclass Solution:\n    def sortColors(self, nums):\n        low, mid, high = 0, 0, len(nums) - 1\n\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:  # nums[mid] == 2\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1\n```\n\n### Complexity Analysis\n- **Time Complexity**: O(n), where n is the number of elements in the array, as we only make a single pass through the array.\n- **Space Complexity**: O(1), as we are using a constant amount of space for our pointers (`low`, `mid`, `high`).\n\nThis algorithm effectively sorts the colors in a single traversal of the array, ensuring that the colors are properly grouped in the required order."
          },
          {
                    "title": "minimum-window-substring",
                    "solution": "### Problem: Minimum Window Substring\n\n#### Intuition\nThe goal is to find the minimum window in string `s` that contains all characters from string `t`. A sliding window approach with two pointers is a suitable technique for this problem.\n\n#### Approach\n1. **Character Frequency Map**: Initialize a character array `map` of size 128 to store the frequency of characters in string `t`.\n2. **Initialize Variables**:\n   - `count`: Total number of characters in `t` that need to be matched.\n   - `start` and `end`: Two pointers for the current window in `s`.\n   - `minLen` and `startIndex`: To track the minimum window size and starting index respectively.\n3. **Sliding Window Technique**:\n   - Iterate through each character in `s`, expanding the `end` pointer.\n   - For each character, decrement its frequency in `map` and check if it's part of the window. If it matches a required character, reduce `count`.\n   - When all required characters are matched (`count == 0`):\n     - Check if the current window is smaller than the previously found minimum window and update `minLen` and `startIndex` if necessary.\n     - Increment the `start` pointer to reduce the window size and check if it can still form a valid window.\n4. **Return Result**: After processing, return the substring from `s` from `startIndex` with length `minLen`.\n\n### Code Implementation\n\nHere's a concise implementation in C++:\n\n```cpp\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        if (s.empty() || t.empty() || s.length() < t.length()) {\n            return \"\";\n        }\n\n        vector<int> map(128, 0);\n        for (char c : t) {\n            map[c]++;\n        }\n\n        int count = t.length();\n        int start = 0, end = 0, minLen = INT_MAX, startIndex = 0;\n\n        while (end < s.length()) {\n            if (map[s[end++]]-- > 0) {\n                count--;\n            }\n\n            while (count == 0) {\n                if (end - start < minLen) {\n                    startIndex = start;\n                    minLen = end - start;\n                }\n                if (map[s[start++]]++ == 0) {\n                    count++;\n                }\n            }\n        }\n\n        return minLen == INT_MAX ? \"\" : s.substr(startIndex, minLen);\n    }\n};\n```\n\n### Complexity Analysis\n- **Time Complexity**: O(n), where n is the length of string `s`. Each character is processed at most twice (once by `end` and once by `start`).\n- **Space Complexity**: O(1), as the size of the frequency map is constant (128 for ASCII characters). \n\nThis approach efficiently finds the minimum window substring that includes all characters of `t` within `s`."
          },
          {
                    "title": "subsets",
                    "solution": "Here's a clear and concise solution for generating subsets of a given set, using different approaches demonstrated in the provided user input:\n\n### 1. Recursive Backtracking Approach\n```java\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    backtrack(result, new ArrayList<>(), nums, 0);\n    return result;\n}\n\nprivate void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, int start) {\n    result.add(new ArrayList<>(tempList));\n    for (int i = start; i < nums.length; i++) {\n        tempList.add(nums[i]);\n        backtrack(result, tempList, nums, i + 1);\n        tempList.remove(tempList.size() - 1);\n    }\n}\n```\n\n### 2. Iterative Approach\n```java\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    result.add(new ArrayList<>()); // Start with an empty subset\n    for (int num : nums) {\n        int size = result.size();\n        for (int i = 0; i < size; i++) {\n            List<Integer> newSubset = new ArrayList<>(result.get(i));\n            newSubset.add(num);\n            result.add(newSubset);\n        }\n    }\n    return result;\n}\n```\n\n### 3. Bit Manipulation Approach\n```java\npublic List<List<Integer>> subsets(int[] nums) {\n    int n = nums.length;\n    int totalSubsets = 1 << n; // 2^n\n    List<List<Integer>> result = new ArrayList<>();\n    \n    for (int i = 0; i < totalSubsets; i++) {\n        List<Integer> subset = new ArrayList<>();\n        for (int j = 0; j < n; j++) {\n            if ((i & (1 << j)) != 0) { // Check if jth bit is set\n                subset.add(nums[j]);\n            }\n        }\n        result.add(subset);\n    }\n    return result;\n}\n```\n\n### 4. Python Recursive Backtracking Approach\n```python\nclass Solution:\n    def subsets(self, nums):\n        result = []\n        self.dfs(nums, [], result)\n        return result\n\n    def dfs(self, nums, path, result):\n        result.append(path)\n        for i in range(len(nums)):\n            self.dfs(nums[i + 1:], path + [nums[i]], result)\n```\n\n### 5. Python Iterative Approach\n```python\nclass Solution:\n    def subsets(self, nums):\n        result = [[]]\n        for num in nums:\n            result += [subset + [num] for subset in result]\n        return result\n```\n\n### 6. Python Bit Manipulation Approach\n```python\nclass Solution:\n    def subsets(self, nums):\n        res = []\n        for i in range(1 << len(nums)):\n            subset = []\n            for j in range(len(nums)):\n                if i & (1 << j): # Bit is set\n                    subset.append(nums[j])\n            res.append(subset)\n        return res\n```\n\nThese implementations efficiently generate all possible subsets of the input array using various techniques including recursive backtracking, iterative approaches, and bit manipulation. You can choose any approach based on your preference for clarity or performance needs."
          },
          {
                    "title": "word-search",
                    "solution": "Here's a clear and concise solution to the \"Word Search\" problem using depth-first search (DFS). The approach involves traversing the grid to find each character of the word in all four possible directions.\n\n### Solution\n\nThe algorithm employs a recursive function (`backtrack`) to explore the grid. Here's the implementation in Python:\n\n```python\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        R, C = len(board), len(board[0])\n\n        if len(word) > R * C:\n            return False\n\n        # Function to perform the DFS\n        def backtrack(r, c, index):\n            if index == len(word):\n                return True\n            if r < 0 or c < 0 or r >= R or c >= C or board[r][c] != word[index]:\n                return False\n            \n            # Temporarily mark the current cell as visited\n            temp = board[r][c]\n            board[r][c] = '#'  # Mark as visited\n            \n            # Explore all four directions\n            found = (\n                backtrack(r + 1, c, index + 1) or\n                backtrack(r - 1, c, index + 1) or\n                backtrack(r, c + 1, index + 1) or\n                backtrack(r, c - 1, index + 1)\n            )\n            \n            # Restore the original value after visiting\n            board[r][c] = temp\n            return found\n\n        # Iterate through each cell of the grid\n        for i in range(R):\n            for j in range(C):\n                if backtrack(i, j, 0):  # Start DFS if the first character matches\n                    return True\n        \n        return False\n```\n\n### Explanation:\n1. **Initialization**: \n   - Variables `R` and `C` hold the number of rows and columns in the board, respectively.\n   - A check is done to see if the word's length exceeds the total number of cells.\n\n2. **DFS Function (`backtrack`)**:\n   - Base case: If the index matches the word length, the word has been completely found.\n   - Boundary checks ensure the row and column are within valid limits and match the character of the word.\n   - The current cell is marked temporarily to prevent revisiting, and DFS is called recursively for adjacent cells (up, down, left, right).\n   - After exploring, the original character is restored.\n\n3. **Main Loop**: \n   - Each cell in the board is checked to see if it can be the start of the word (i.e., it matches the first character).\n   - If any path through the grid returns `True`, the function exits early.\n\n### Time and Space Complexity:\n- **Time Complexity**: O(m * n * 4^l), where `m` and `n` are the dimensions of the board, and `l` is the length of the word.\n- **Space Complexity**: O(l) due to the depth of recursion stack.\n\nThis implementation efficiently checks for the presence of the word in the grid and adheres to constraints posed by the problem."
          },
          {
                    "title": "largest-rectangle-in-histogram",
                    "solution": "Here's a concise and clear solution for the problem of finding the largest rectangle in a histogram:\n\n### Problem: Largest Rectangle in Histogram\n\nGiven an array `heights` representing the heights of bars in a histogram, your task is to find the area of the largest rectangle that can be formed within the histogram.\n\n### Approach:\n\nTo solve this problem efficiently, we can use a stack data structure to keep track of the indices of the bars in the histogram. The main idea is to maintain a stack such that the heights of the bars correspond to an increasing sequence. When we encounter a bar that is lower than the bar at the index stored at the top of the stack, we pop from the stack and calculate the area of the rectangle that can be formed with the popped bar as the shortest bar.\n\n### Steps:\n1. Append a sentinel value `0` to the end of the `heights` array to ensure all bars are processed.\n2. Initialize a stack to keep track of the indices of the bars.\n3. Iterate over the bars:\n   - While the stack is not empty and the current height is less than the height of the bar at the index stored at the top of the stack, pop from the stack:\n     - Calculate the height as the height of the popped bar.\n     - Determine the width using the current index and the index of the bar now at the top of the stack (if the stack is empty, use the current index).\n     - Update the maximum area found.\n   - Push the current index onto the stack.\n4. Return the maximum area found.\n\n### Code:\n\nHere is the complete implementation in Java and Python:\n\n#### Java:\n```java\nimport java.util.Stack;\n\npublic class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int len = heights.length;\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        \n        for (int i = 0; i <= len; i++) {\n            int h = (i == len ? 0 : heights[i]);\n            while (!stack.isEmpty() && h < heights[stack.peek()]) {\n                int tp = stack.pop();\n                maxArea = Math.max(maxArea, heights[tp] * (stack.isEmpty() ? i : i - 1 - stack.peek()));\n            }\n            stack.push(i);\n        }\n        return maxArea;\n    }\n}\n```\n\n#### Python:\n```python\nclass Solution:\n    def largestRectangleArea(self, heights):\n        stack, max_area = [], 0\n        heights.append(0)  # Append sentinel\n        \n        for i, h in enumerate(heights):\n            while stack and heights[stack[-1]] > h:\n                height = heights[stack.pop()]  # Height of the rectangle\n                width = i if not stack else i - stack[-1] - 1  # Width calculation\n                max_area = max(max_area, height * width)\n            stack.append(i)  # Push current index\n        \n        return max_area\n```\n\n### Complexity:\n- **Time Complexity:** O(n), where n is the number of bars in the histogram.\n- **Space Complexity:** O(n) for the stack.\n\nThis algorithm efficiently calculates the largest rectangle area in a histogram using a single traversal of the heights array, making it optimal for large inputs."
          },
          {
                    "title": "merge-sorted-array",
                    "solution": "Here is a clear and concise solution for merging two sorted arrays into one, leveraging the approach using two pointers.\n\n## Problem Statement\nYou are given two sorted arrays, `nums1` and `nums2`, and you must merge `nums2` into `nums1` such that `nums1` is sorted. You may assume that `nums1` has enough space (size `m + n`) to hold the elements of both arrays.\n\n## Approach: Two Pointers\n1. Start with three pointers:\n   - `i` initialized to `m - 1` (last index of `nums1`'s initial elements).\n   - `j` initialized to `n - 1` (last index of `nums2`).\n   - `k` initialized to `m + n - 1` (last index of `nums1`).\n   \n2. Compare the elements pointed by `i` and `j` and place the larger one at position `k` in `nums1`.\n\n3. Decrement `k` and the pointer (`i` or `j`) based on which element was larger.\n\n4. If there are remaining elements in `nums2`, continue placing them in `nums1`.\n\n5. If `nums1` still has elements left, they are already in correct position.\n\n## Complexity\n- Time complexity: O(m + n) because we traverse each array once.\n- Space complexity: O(1) since we do not use any additional space.\n\n## Code\n\nHere is the implementation in Python, C++, Java, and JavaScript:\n\n### Python\n```python\nclass Solution:\n    def merge(self, nums1, m, nums2, n):\n        i, j, k = m - 1, n - 1, m + n - 1\n        \n        while j >= 0:\n            if i >= 0 and nums1[i] > nums2[j]:\n                nums1[k] = nums1[i]\n                i -= 1\n            else:\n                nums1[k] = nums2[j]\n                j -= 1\n            k -= 1\n```\n\n### C++\n```cpp\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int i = m - 1, j = n - 1, k = m + n - 1;\n        \n        while (j >= 0) {\n            if (i >= 0 && nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n    }\n};\n```\n\n### Java\n```java\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int i = m - 1, j = n - 1, k = m + n - 1;\n        \n        while (j >= 0) {\n            if (i >= 0 && nums1[i] > nums2[j]) {\n                nums1[k--] = nums1[i--];\n            } else {\n                nums1[k--] = nums2[j--];\n            }\n        }\n    }\n}\n```\n\n### JavaScript\n```javascript\nvar merge = function(nums1, m, nums2, n) {\n    let i = m - 1, j = n - 1, k = m + n - 1;\n    \n    while (j >= 0) {\n        if (i >= 0 && nums1[i] > nums2[j]) {\n            nums1[k--] = nums1[i--];\n        } else {\n            nums1[k--] = nums2[j--];\n        }\n    }\n};\n```\n\nThis implementation effectively merges both sorted arrays into `nums1` while maintaining sorted order and uses a direct approach with pointers to avoid extra space usage and unnecessary sorting."
          },
          {
                    "title": "decode-ways",
                    "solution": "Here's a clear and concise solution for the problem of decoding ways, distilled from the user's various solutions:\n\n### Problem Description:\nGiven a string `s` consisting of digits, determine the total number of ways to decode it, where '1' to '26' represent letters 'A' to 'Z'. For example, the string \"12\" can be decoded as \"AB\" (1 2) or \"L\" (12), hence it has 2 ways to decode.\n\n### Solution Approaches:\n\n1. **Recursion (Exponential Time O(2^n))**:\n   ```cpp\n   int numDecodings(string s) {\n       return s.empty() ? 0 : decode(0, s);\n   }\n\n   int decode(int index, string &s) {\n       if (index == s.size()) return 1;\n       if (s[index] == '0') return 0; // Invalid encoding\n       int count = decode(index + 1, s);\n       if (index < s.size() - 1 && (s[index] == '1' || (s[index] == '2' && s[index + 1] < '7')))\n           count += decode(index + 2, s);\n       return count;\n   }\n   ```\n\n2. **Memoization (O(n) Time and Space)**:\n   ```cpp\n   int numDecodings(string s) {\n       vector<int> memo(s.size() + 1, -1);\n       memo[s.size()] = 1; // Base case\n       return helper(0, s, memo);\n   }\n\n   int helper(int index, string &s, vector<int> &memo) {\n       if (memo[index] != -1) return memo[index];\n       if (s[index] == '0') return memo[index] = 0;\n       int count = helper(index + 1, s, memo);\n       if (index < s.size() - 1 && (s[index] == '1' || (s[index] == '2' && s[index + 1] < '7')))\n           count += helper(index + 2, s, memo);\n       return memo[index] = count;\n   }\n   ```\n\n3. **Dynamic Programming (Bottom-Up) (O(n) Time and Space)**:\n   ```cpp\n   int numDecodings(string s) {\n       if (s.empty()) return 0;\n       int n = s.size();\n       vector<int> dp(n + 1, 0);\n       dp[0] = 1; // One way to decode an empty string\n       dp[1] = s[0] != '0' ? 1 : 0; // Check if the first character is valid\n\n       for (int i = 2; i <= n; i++) {\n           int oneDigit = stoi(s.substr(i - 1, 1));\n           int twoDigits = stoi(s.substr(i - 2, 2));\n\n           if (oneDigit >= 1) dp[i] += dp[i - 1];\n           if (twoDigits >= 10 && twoDigits <= 26) dp[i] += dp[i - 2];\n       }\n       return dp[n];\n   }\n   ```\n\n4. **Optimized Dynamic Programming (Constant Space O(n) Time, O(1) Space)**:\n   ```cpp\n   int numDecodings(string s) {\n       if (s.empty()) return 0;\n       int n = s.size();\n       int prev = 1, curr = 0;\n       \n       curr = s[0] != '0' ? 1 : 0; // Initialize for the first character\n\n       for (int i = 1; i < n; i++) {\n           int temp = curr;\n           if (s[i] == '0') {\n               curr = 0; // Can't decode if current digit is '0'\n           }\n           if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] < '7')) {\n               curr += prev; // Add ways when valid two-digit number\n           }\n           prev = temp; // Move to the next step in sequence\n       }\n       return curr; // Total ways\n   }\n   ```\n\n### Complexity:\n- **Time Complexity**: O(n), where n is the length of the string.\n- **Space Complexity**: O(1) for the optimized version and O(n) for both bottom-up DP and memoization approaches.\n\nThis concise presentation captures the essence of decoding ways with varying techniques for solving the problem, using recursion, memoization, dynamic programming, and space optimization."
          },
          {
                    "title": "binary-tree-inorder-traversal",
                    "solution": "Here’s a clear and concise solution to the problem of traversing a binary tree in inorder:\n\n### Inorder Traversal Solution\n\n**Iterative Solution Using Stack**\nThis method uses a stack to keep track of nodes and processes the leftmost nodes first, then visits the current node, followed by the right node.\n\n```cpp\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> nodes;\n        stack<TreeNode*> todo;\n        while (root || !todo.empty()) {\n            while (root) {\n                todo.push(root);\n                root = root->left;\n            }\n            root = todo.top();\n            todo.pop();\n            nodes.push_back(root->val);\n            root = root->right;\n        }\n        return nodes;\n    }\n};\n```\n\n**Recursive Solution**\nThis solution recursively processes the left subtree, visits the root node, and then processes the right subtree.\n\n```cpp\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> nodes;\n        inorder(root, nodes);\n        return nodes;\n    }\n    \nprivate:\n    void inorder(TreeNode* root, vector<int>& nodes) {\n        if (!root) {\n            return;\n        }\n        inorder(root->left, nodes);\n        nodes.push_back(root->val);\n        inorder(root->right, nodes);\n    }\n};\n```\n\n**Morris Traversal (Threaded Binary Tree)**\nThis innovative solution does not use additional space for stack or recursion, achieving `O(1)` space complexity.\n\n```cpp\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> nodes;\n        while (root) {\n            if (root->left) {\n                TreeNode* pre = root->left;\n                while (pre->right && pre->right != root) {\n                    pre = pre->right;\n                }\n                if (!pre->right) {\n                    pre->right = root;  // Create a thread\n                    root = root->left;\n                } else {\n                    pre->right = nullptr;  // Remove the thread\n                    nodes.push_back(root->val);\n                    root = root->right;\n                }\n            } else {\n                nodes.push_back(root->val);\n                root = root->right;\n            }\n        }\n        return nodes;\n    }\n};\n```\n\n### Time and Space Complexity\n- **Time Complexity:** `O(n)` for all methods, where `n` is the number of nodes in the tree.\n- **Space Complexity:**\n  - Iterative solution: `O(n)` due to the stack.\n  - Recursive solution: `O(h)`, where `h` is the height of the tree for the function call stack.\n  - Morris traversal: `O(1)` as it uses no additional space. \n\nThis approach efficiently captures the concept of inorder traversal for binary trees using different techniques."
          },
          {
                    "title": "validate-binary-search-tree",
                    "solution": "Here’s a clear and concise summary of the solutions to the various LeetCode problems related to binary tree traversal and validation using iterative and recursive techniques in Java, C++, and Python:\n\n### 1. Binary Tree Inorder Traversal\n**Problem:** Traverse a binary tree in inorder (left, root, right) iteratively using a stack.\n\n**Java:**\n```java\npublic List<Integer> inorderTraversal(TreeNode root) {\n    List<Integer> list = new ArrayList<>();\n    Stack<TreeNode> stack = new Stack<>();\n    while (root != null || !stack.empty()) {\n        while (root != null) {\n            stack.push(root);\n            root = root.left;\n        }\n        root = stack.pop();\n        list.add(root.val);\n        root = root.right;\n    }\n    return list;\n}\n```\n\n### 2. Kth Smallest Element in a BST\n**Problem:** Find the Kth smallest element in a binary search tree (BST) using iterative inorder traversal.\n\n**Java:**\n```java\npublic int kthSmallest(TreeNode root, int k) {\n    Stack<TreeNode> stack = new Stack<>();\n    while (root != null || !stack.isEmpty()) {\n        while (root != null) {\n            stack.push(root);\n            root = root.left;\n        }\n        root = stack.pop();\n        if (--k == 0) return root.val;\n        root = root.right;\n    }\n    return -1; // Should not reach here if k is valid\n}\n```\n\n### 3. Validate Binary Search Tree\n**Problem:** Validate if a given binary tree is a BST using iterative and recursive methods.\n\n#### Iterative Method (Java):\n```java\npublic boolean isValidBST(TreeNode root) {\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode pre = null;\n    while (root != null || !stack.isEmpty()) {\n        while (root != null) {\n            stack.push(root);\n            root = root.left;\n        }\n        root = stack.pop();\n        if (pre != null && root.val <= pre.val) return false;\n        pre = root;\n        root = root.right;\n    }\n    return true;\n}\n```\n\n#### Recursive Method (Java):\n```java\npublic boolean isValidBST(TreeNode root) {\n    return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\n}\n\nprivate boolean isValidBST(TreeNode root, long minVal, long maxVal) {\n    if (root == null) return true;\n    if (root.val <= minVal || root.val >= maxVal) return false;\n    return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\n}\n```\n\n#### C++:\n```cpp\nbool isValidBST(TreeNode* root) {\n    return isValidBST(root, LONG_MIN, LONG_MAX);\n}\n\nbool isValidBST(TreeNode* root, long minVal, long maxVal) {\n    if (!root) return true;\n    if (root->val <= minVal || root->val >= maxVal) return false;\n    return isValidBST(root->left, minVal, root->val) && isValidBST(root->right, root->val, maxVal);\n}\n```\n\n#### Python:\n```python\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        def inorder(node, prev):\n            if not node:\n                return True\n            if not inorder(node.left, prev):\n                return False\n            if prev[0] >= node.val:\n                return False\n            prev[0] = node.val\n            return inorder(node.right, prev)\n\n        return inorder(root, [float('-inf')])\n```\n\n### Summary\nThese solutions utilize iterative and recursive methods to solve problems regarding binary trees, demonstrating effective techniques like inorder traversal for both retrieving values in a sorted order and validating the properties of a binary search tree."
          },
          {
                    "title": "symmetric-tree",
                    "solution": "Here’s a clear and concise solution to the problem of determining if a binary tree is symmetric:\n\n### Problem Statement\nGiven a binary tree, check whether it is a mirror of itself (symmetric around its center).\n\n### Approach\nWe can solve this problem using both recursive and iterative methods. The recursive approach directly compares the left and right subtrees. For the iterative approach, we can use a stack or queue to compare the nodes iteratively.\n\n### Recursive Solution\nThis method utilizes a helper function to check if two trees are mirror images of each other. If both nodes are null, they are symmetric. If one is null while the other is not, they are not symmetric. If both nodes have the same value, we recursively check their children.\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        return isMirror(root.left, root.right);\n    }\n\n    private boolean isMirror(TreeNode left, TreeNode right) {\n        if (left == null && right == null) return true;\n        if (left == null || right == null) return false;\n        return (left.val == right.val) && isMirror(left.left, right.right) && isMirror(left.right, right.left);\n    }\n}\n```\n\n### Iterative Solution\nThe iterative approach uses a queue to perform level-order traversal and compare corresponding nodes from the left and right subtrees.\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        if (root == null) return true;\n\n        Queue<TreeNode> q1 = new LinkedList<>();\n        Queue<TreeNode> q2 = new LinkedList<>();\n        q1.offer(root.left);\n        q2.offer(root.right);\n\n        while (!q1.isEmpty() && !q2.isEmpty()) {\n            TreeNode left = q1.poll();\n            TreeNode right = q2.poll();\n\n            if (left == null && right == null) continue;\n            if (left == null || right == null || left.val != right.val) return false;\n\n            q1.offer(left.left);\n            q1.offer(left.right);\n            q2.offer(right.right);\n            q2.offer(right.left);\n        }\n\n        return true;\n    }\n}\n```\n\n### Complexity\n- **Time Complexity**: O(n), where n is the number of nodes in the tree, since we need to visit each node at least once.\n- **Space Complexity**:\n  - Recursive: O(h), where h is the height of the tree due to the recursion stack.\n  - Iterative: O(w), where w is the maximum width of the queue during traversal.\n\nChoose either approach based on your preference for recursive or iterative solutions. Both effectively check for symmetry in a binary tree."
          },
          {
                    "title": "binary-tree-level-order-traversal",
                    "solution": "Here's a clear and concise solution for the level order traversal of a binary tree:\n\n### Java\n```java\nimport java.util.*;\n\npublic class Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        traverse(result, root, 0);\n        return result;\n    }\n\n    private void traverse(List<List<Integer>> result, TreeNode node, int level) {\n        if (node == null) return;\n\n        if (level >= result.size()) {\n            result.add(new ArrayList<>());\n        }\n        result.get(level).add(node.val);\n\n        traverse(result, node.left, level + 1);\n        traverse(result, node.right, level + 1);\n    }\n}\n```\n\n### C++\n```cpp\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> result;\n        if (root == nullptr) return result;\n\n        queue<TreeNode*> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            int levelSize = q.size();\n            vector<int> currentLevel;\n\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n\n                currentLevel.push_back(node->val);\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            result.push_back(currentLevel);\n        }\n        return result;\n    }\n};\n```\n\n### Python\n```python\nfrom collections import deque\n\nclass Solution:\n    def levelOrder(self, root):\n        if not root:\n            return []\n        \n        result = []\n        queue = deque([root])\n\n        while queue:\n            level_size = len(queue)\n            current_level = []\n\n            for _ in range(level_size):\n                node = queue.popleft()\n                current_level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            result.append(current_level)\n\n        return result\n```\n\n### Explanation\n- **Approach**: The level order traversal can be implemented using either breadth-first search (BFS) with a queue or a depth-first search (DFS) using recursion.\n- **BFS**: Each level of the tree is processed one by one, and nodes' values are collected into a list before moving deeper.\n- **DFS**: The nodes are traversed recursively while keeping track of the current level, adding values to the corresponding list in the result. \n\nBoth methods achieve the same result, returning a list of lists where each inner list contains the values of the nodes at the same depth level in the tree."
          },
          {
                    "title": "binary-tree-zigzag-level-order-traversal",
                    "solution": "Here's a clear and concise solution for the zigzag level order traversal of a binary tree using BFS (Breadth-First Search):\n\n### C++ Solution\n\n```cpp\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        vector<vector<int>> result;\n        if (!root) return result;\n\n        queue<TreeNode*> nodesQueue;\n        nodesQueue.push(root);\n        bool leftToRight = true;  // Flag to alternate direction\n\n        while (!nodesQueue.empty()) {\n            int size = nodesQueue.size();  // Number of nodes at current level\n            vector<int> row(size);  // Prepare a vector for current level\n\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = nodesQueue.front();\n                nodesQueue.pop();\n\n                // Assign node value to the correct position based on current direction\n                int index = leftToRight ? i : (size - 1 - i);\n                row[index] = node->val;\n\n                // Add child nodes to queue for the next level\n                if (node->left) nodesQueue.push(node->left);\n                if (node->right) nodesQueue.push(node->right);\n            }\n\n            result.push_back(row);  // Add the current level to the result\n            leftToRight = !leftToRight;  // Toggle direction for the next level\n        }\n        return result;\n    }\n};\n```\n\n### Python Solution\n\n```python\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        \n        result = []\n        queue = deque([root])\n        direction = 1  # 1 for left-to-right, -1 for right-to-left\n\n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.popleft()\n                level.append(node.val)\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            # Depending on direction, append level accordingly\n            if direction == 1:\n                result.append(level)\n            else:\n                result.append(level[::-1])\n            direction *= -1  # Toggle the direction\n\n        return result\n```\n\n### Explanation:\n1. We utilize a queue to perform level order traversal.\n2. A boolean flag (`leftToRight`) or an integer (`direction`) is used to keep track of the current level's traversal direction.\n3. For each level, we create a vector (`row`) to store the node values. Depending on the traversal direction, values are stored either from left to right or from right to left.\n4. After traversing all nodes at the current level, we add the row to the result and toggle the direction for the next level.\n5. The time complexity is O(n) and the space complexity is O(n), where n is the number of nodes in the binary tree."
          },
          {
                    "title": "maximum-depth-of-binary-tree",
                    "solution": "To solve the problem of finding the maximum depth of a binary tree, we can utilize both recursive (DFS) and iterative (BFS) approaches. Below are the concise and clear implementations of both methods.\n\n### Recursive Depth-First Search (DFS)\n\nThis method uses recursion to traverse the tree. The maximum depth is determined by the maximum depth of the left and right subtrees, plus one for the current node.\n\n```cpp\nint maxDepth(TreeNode* root) {\n    if (!root) {\n        return 0; // Base case: if the node is null, depth is 0.\n    }\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\n}\n```\n\n### Iterative Depth-First Search (DFS)\n\nIn this iterative approach, we use a stack to keep track of nodes and their corresponding depths.\n\n```java\npublic int maxDepth(TreeNode root) {\n    if (root == null) {\n        return 0; // Base case\n    }\n    \n    Stack<TreeNode> stack = new Stack<>();\n    Stack<Integer> depthStack = new Stack<>();\n    stack.push(root);\n    depthStack.push(1); // Start from depth 1\n\n    int maxDepth = 0;\n    \n    while (!stack.isEmpty()) {\n        TreeNode node = stack.pop();\n        int depth = depthStack.pop();\n        maxDepth = Math.max(maxDepth, depth); // Update max depth\n        \n        if (node.left != null) {\n            stack.push(node.left);\n            depthStack.push(depth + 1);\n        }\n        if (node.right != null) {\n            stack.push(node.right);\n            depthStack.push(depth + 1);\n        }\n    }\n    \n    return maxDepth;\n}\n```\n\n### Breadth-First Search (BFS)\n\nThis method uses a queue to traverse the tree level by level and counts the number of levels.\n\n```java\npublic int maxDepth(TreeNode root) {\n    if (root == null) {\n        return 0; // Base case\n    }\n    \n    Queue<TreeNode> queue = new LinkedList<>();\n    queue.offer(root);\n    int depth = 0;\n    \n    while (!queue.isEmpty()) {\n        int levelSize = queue.size(); // Get the number of nodes at the current level\n        depth++; // Increase depth for the current level\n        \n        for (int i = 0; i < levelSize; i++) {\n            TreeNode node = queue.poll();\n            if (node.left != null) {\n                queue.offer(node.left);\n            }\n            if (node.right != null) {\n                queue.offer(node.right);\n            }\n        }\n    }\n    \n    return depth;\n}\n```\n\n### Complexity Analysis\n- **Time Complexity**: O(N), where N is the number of nodes in the tree, since we visit each node once.\n- **Space Complexity**:\n  - For the recursive approach, O(H), where H is the height of the tree due to the call stack.\n  - For the iterative (DFS and BFS) methods, O(W), where W is the maximum width of the tree, used by the stacks or queue for node storage.\n\nFeel free to ask if you have any more questions or need further assistance!"
          },
          {
                    "title": "construct-binary-tree-from-preorder-and-inorder-traversal",
                    "solution": "Here's a clear and concise solution to building a binary tree from preorder and inorder traversal data. The algorithm leverages the properties of these traversals to reconstruct the tree efficiently without unnecessary splits or searches:\n\n### Algorithm Explanation:\n1. **Preorder Traversal**: The first element is always the root of the tree.\n2. **Inorder Traversal**: Elements in the left subtree appear before the root, and those in the right subtree appear after the root.\n3. Use a recursive approach:\n   - Find the root from the preorder array.\n   - Locate the index of the root in the inorder array to determine the boundaries of the left and right subtrees.\n   - Recursively construct the left and right subtrees.\n\n### Java Solution:\n```java\nclass Solution {\n    private int preIndex = 0;\n\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        return build(preorder, inorder, 0, inorder.length - 1);\n    }\n\n    private TreeNode build(int[] preorder, int[] inorder, int inStart, int inEnd) {\n        if (inStart > inEnd) return null;\n\n        // The root node is the current element in preorder\n        TreeNode root = new TreeNode(preorder[preIndex++]);\n\n        // Find the index of the root in inorder\n        int inIndex = 0;\n        for (int i = inStart; i <= inEnd; i++) {\n            if (inorder[i] == root.val) {\n                inIndex = i;\n                break;\n            }\n        }\n\n        // Build left and right subtree recursively\n        root.left = build(preorder, inorder, inStart, inIndex - 1);\n        root.right = build(preorder, inorder, inIndex + 1, inEnd);\n        return root;\n    }\n}\n```\n\n### Python Solution:\n```python\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        self.preIndex = 0\n        \n        def build(inStart, inEnd):\n            if inStart > inEnd:\n                return None\n\n            # The root node is the current element in preorder\n            root = TreeNode(preorder[self.preIndex])\n            self.preIndex += 1\n            \n            # Find the index of the root in inorder\n            inIndex = inorder.index(root.val)\n            \n            # Build left and right subtree recursively\n            root.left = build(inStart, inIndex - 1)\n            root.right = build(inIndex + 1, inEnd)\n            return root\n        \n        return build(0, len(inorder) - 1)\n```\n\n### C++ Solution:\n```cpp\nclass Solution {\npublic:\n    int preIndex = 0;\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        return build(preorder, inorder, 0, inorder.size() - 1);\n    }\n\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int inStart, int inEnd) {\n        if (inStart > inEnd) return nullptr;\n\n        // The root node is the current element in preorder\n        TreeNode* root = new TreeNode(preorder[preIndex++]);\n\n        // Find the index of the root in inorder\n        int inIndex = findIndex(inorder, root->val, inStart, inEnd);\n\n        // Build left and right subtree recursively\n        root->left = build(preorder, inorder, inStart, inIndex - 1);\n        root->right = build(preorder, inorder, inIndex + 1, inEnd);\n        return root;\n    }\n\n    int findIndex(vector<int>& inorder, int value, int inStart, int inEnd) {\n        for (int i = inStart; i <= inEnd; ++i) {\n            if (inorder[i] == value) {\n                return i;\n            }\n        }\n        return -1; // Should never reach here if input is valid\n    }\n};\n```\n\n### Summary:\nThe above implementations efficiently construct a binary tree using preorder and inorder arrays. They utilize recursive function calls to build the tree from the current root and properly handle subtrees, thus achieving a clear and systematic solution to the problem."
          },
          {
                    "title": "convert-sorted-array-to-binary-search-tree",
                    "solution": "Here’s a concise and clear solution to the problem of converting a sorted array to a height-balanced binary search tree (BST) using recursion in Python:\n\n```python\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        if not nums:\n            return None\n\n        mid = len(nums) // 2\n        root = TreeNode(nums[mid])  # Middle element as the root\n        \n        # Recursively build left and right subtrees\n        root.left = self.sortedArrayToBST(nums[:mid])  # Left subarray\n        root.right = self.sortedArrayToBST(nums[mid + 1:])  # Right subarray\n\n        return root\n```\n\n### Explanation:\n1. **Base Case**: If the input array is empty, return `None`.\n2. **Recursive Case**: \n   - Find the middle index of the array and create a tree node (`TreeNode`) with the middle element as its value.\n   - Recursively create the left subtree using the left subarray (elements before the middle).\n   - Recursively create the right subtree using the right subarray (elements after the middle).\n3. The result is a height-balanced binary search tree.\n\n### Time Complexity:\n- **O(n)**: Every element from the array is processed exactly once.\n\n### Space Complexity:\n- **O(log n)**: Space used by the recursion stack for height-balanced BST."
          },
          {
                    "title": "populating-next-right-pointers-in-each-node",
                    "solution": "Here is a clear and concise solution for the problem of connecting the next pointers in a perfect binary tree:\n\n### C++ Solution (Iterative)\n```cpp\nclass Solution {\npublic:\n    void connect(TreeLinkNode *root) {\n        TreeLinkNode *level_start = root;\n        while (level_start) {\n            TreeLinkNode *cur = level_start; // Start at the beginning of the current level\n            while (cur) { // Traverse the current level\n                if (cur->left) cur->left->next = cur->right; // Link left child to right child\n                if (cur->right && cur->next) // Link right child to the next left child if exists\n                    cur->right->next = cur->next->left;\n                cur = cur->next; // Move to the next node in the current level\n            }\n            level_start = level_start->left; // Move to the next level\n        }\n    }\n};\n```\n\n### Python Solution (Iterative)\n```python\nclass Solution:\n    def connect(self, root):\n        while root and root.left: # Proceed until we reach the last level\n            cur = root\n            while cur: # Traverse the current level\n                cur.left.next = cur.right # Link left child to right child\n                cur.right.next = cur.next.left if cur.next else None # Link right child to the next left child, if exists\n                cur = cur.next # Move to the next node in the current level\n            root = root.left # Move to the next level\n```\n\n### Java Solution (Recursive)\n```java\npublic class Solution {\n    public void connect(TreeLinkNode root) {\n        if (root == null) return; // Base case\n        if (root.left != null) { // Ensure left child exists\n            root.left.next = root.right; // Connect left to right\n            if (root.next != null) // Connect right to the next level's left, if exists\n                root.right.next = root.next.left;\n        }\n        connect(root.left); // Recur for left subtree\n        connect(root.right); // Recur for right subtree\n    }\n}\n```\n\n### Key Points\n- We can leverage the property of the perfect binary tree where every parent has exactly two children to set the `next` pointers.\n- In the iterative solution, we traverse each level from left to right using a while loop and directly assign `next` pointers.\n- In the recursive approach, we handle each node and its children by making recursive calls after linking.\n\n### Complexity\n- **Time Complexity:** O(N), where N is the number of nodes in the tree, since each node is processed once.\n- **Space Complexity:** O(1) in the iterative solution due to the use of constant space. The recursive solution has O(log N) space complexity due to the recursive call stack."
          },
          {
                    "title": "pascals-triangle",
                    "solution": "Here's a clear and concise solution to the problem of generating Pascal's triangle based on the provided approaches:\n\n### Pascal's Triangle Solution\n\n**Problem Statement:** Generate Pascal's triangle with a given number of rows.\n\n### Approaches\n\n1. **Using Dynamic Programming (2D Array)** \n\n   This is the most straightforward approach by utilizing a 2D array to store the triangle.\n\n   ```cpp\n   class Solution {\n   public:\n       vector<vector<int>> generate(int numRows) {\n           vector<vector<int>> ans(numRows);\n           for (int i = 0; i < numRows; ++i) {\n               ans[i].resize(i + 1, 1); // Initialize each row with 1s\n               for (int j = 1; j < i; ++j) {\n                   ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j]; // Fill in the values\n               }\n           }\n           return ans;\n       }\n   };\n   ```\n\n2. **Using Dynamic Programming (1D Array)**\n\n   This approach uses a single list to save memory and compute values in place.\n\n   ```cpp\n   class Solution {\n   public:\n       vector<vector<int>> generate(int numRows) {\n           vector<vector<int>> ans;\n           for (int i = 0; i < numRows; ++i) {\n               vector<int> row(i + 1, 1); // Start each row with 1\n               for (int j = 1; j < i; ++j) {\n                   row[j] = ans[i - 1][j - 1] + ans[i - 1][j]; // Compute current row values\n               }\n               ans.push_back(row); // Add the row to the triangle\n           }\n           return ans;\n       }\n   };\n   ```\n\n3. **Combinatorial Approach**\n\n   Each element in Pascal's Triangle can be computed using the binomial coefficient.\n\n   ```python\n   class Solution:\n       def generate(self, numRows: int) -> List[List[int]]:\n           result = []\n           for i in range(numRows):\n               row = [1] * (i + 1)\n               for j in range(1, i):\n                   row[j] = result[i - 1][j - 1] + result[i - 1][j]\n               result.append(row)\n           return result\n   ```\n\n### Complexity Analysis\n\n- **Time Complexity:** All the approaches have a time complexity of O(numRows²) since we generate each element of the triangle.\n- **Space Complexity:** \n  - The 2D array approach uses O(numRows²) space.\n  - The 1D array approach is more space-efficient with O(numRows) space.\n  \n### Conclusion\n\nThese methods efficiently generate Pascal's triangle using different techniques suitable for various constraints in programming competitions and interviews."
          },
          {
                    "title": "best-time-to-buy-and-sell-stock",
                    "solution": "To solve the problem of finding the maximum profit from stock prices, we can leverage a simple yet effective algorithm. The key idea is to keep track of the minimum price observed so far and calculate potential profit at each step. Here’s a consolidated solution using this approach:\n\n### Approach\n\n1. **Initialization**: Start by setting the initial minimum price (`min_price`) to the first element of the prices array and an initial maximum profit (`max_profit`) to 0.\n  \n2. **Iterate through Prices**: Loop through the prices starting from the second price:\n   - For each price, calculate the potential profit by subtracting the `min_price` from the current price.\n   - Update `max_profit` if the calculated profit is greater than the current `max_profit`.\n   - Update `min_price` to ensure it holds the lowest price seen thus far.\n\n3. **Return the Result**: After iterating through all prices, `max_profit` will contain the maximum profit that could be achieved.\n\n### Complexity\n- **Time Complexity**: O(n), where n is the number of days/prices since we make a single pass through the prices list.\n- **Space Complexity**: O(1), as we only use a few extra variables for tracking prices and profits.\n\n### Implementation\n\nHere are implementations in Python, Java, and C++:\n\n#### Python\n```python\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n        \n        for price in prices[1:]:\n            max_profit = max(max_profit, price - min_price)\n            min_price = min(min_price, price)\n        \n        return max_profit\n```\n\n#### Java\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int min_price = prices[0];\n        int max_profit = 0;\n\n        for (int i = 1; i < prices.length; i++) {\n            max_profit = Math.max(max_profit, prices[i] - min_price);\n            min_price = Math.min(min_price, prices[i]);\n        }\n\n        return max_profit;\n    }\n}\n```\n\n#### C++\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int min_price = prices[0];\n        int max_profit = 0;\n\n        for (int i = 1; i < prices.size(); i++) {\n            max_profit = max(max_profit, prices[i] - min_price);\n            min_price = min(min_price, prices[i]);\n        }\n\n        return max_profit;\n    }\n};\n```\n\nThis solution efficiently computes the maximum profit you can achieve by only buying and selling once, emphasizing a straightforward and optimal approach. If you have any questions or need further explanations, feel free to ask! Happy coding!"
          },
          {
                    "title": "best-time-to-buy-and-sell-stock-ii",
                    "solution": "Here's a clean and concise solution for the \"Best Time to Buy and Sell Stock II\" problem on LeetCode, based on the provided insights and code snippets:\n\n### Problem Summary\nYou want to maximize your profit with multiple transactions where you can buy and sell stocks. The key observation is that you should buy on a day when the next day's price is higher, sell on the next day, and repeat this for the entire price sequence.\n\n### Solution\n\nHere's a simplified Java solution implementing the greedy approach:\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int profit = 0;\n        // Iterate through the price array starting from the second day\n        for (int i = 1; i < prices.length; i++) {\n            // If the current price is higher than the previous day's price, profit from selling\n            if (prices[i] > prices[i - 1]) {\n                profit += prices[i] - prices[i - 1]; // Add the profit of this transaction\n            }\n        }\n        return profit; // Return the total profit\n    }\n}\n```\n\n### Explanation\n- **Time Complexity**: O(N), where N is the length of the prices array, since we are doing a single pass through the array.\n- **Space Complexity**: O(1), as we are using only a constant amount of additional space.\n\n### Example Walkthrough\nFor the input prices `[7, 1, 5, 3, 6, 4]`:\n- Buy on day 1 (price=1) and sell on day 2 (price=5) => Profit = 4.\n- Buy on day 3 (price=3) and sell on day 4 (price=6) => Profit = 3.\n- Total Profit = 4 + 3 = 7.\n\nThis approach efficiently captures all opportunities for profit based on the price changes while adhering to the conditions imposed by the problem."
          },
          {
                    "title": "binary-tree-maximum-path-sum",
                    "solution": "Here's a clear and concise version of the solution for the Maximum Path Sum problem for a binary tree, explaining the key concepts and providing the code in Python:\n\n## Problem Explanation\n\nThe goal is to find the maximum path sum in a binary tree. A path can start and end at any node and can only go downward. The path must not return upward, meaning each node can be included only once.\n\n### Key Observations\n\n1. **Path Definition**: A valid path could include just the root node, or it could combine values from the left or right child nodes as long as it does not go back up.\n  \n2. **Recursion Approach**: We can use recursion to explore each path starting from the root. For each node, we need to compute:\n   - The maximum sum of the path going through that node, which could include the values from both left and right children.\n   - The maximum gain that can be obtained from the node to contribute to its parent's path sum.\n\n3. **Base Case**: If we reach a null node, it means the contribution to the path from that point is 0.\n\n4. **Updating the Maximum Path Sum**: During the recursion, we will keep track of the maximum path sum encountered so far.\n\n### Code Implementation\n\nHere’s the implementation in Python:\n\n```python\nclass Solution:\n    def maxPathSum(self, root: TreeNode) -> int:\n        self.max_path = float('-inf')  # Initialize to negative infinity to handle all values\n        \n        def get_max_gain(node):\n            # Base case: if the node is None, return 0\n            if not node:\n                return 0\n            \n            # Recur for left and right children\n            gain_on_left = max(get_max_gain(node.left), 0)  # Ignore negative gains\n            gain_on_right = max(get_max_gain(node.right), 0)  # Ignore negative gains\n            \n            # Calculate the maximum path sum passing through the current node\n            current_max_path = node.val + gain_on_left + gain_on_right\n            \n            # Update the global max path sum\n            self.max_path = max(self.max_path, current_max_path)\n            \n            # Return the maximum gain to parent node\n            return node.val + max(gain_on_left, gain_on_right)\n        \n        get_max_gain(root)  # Start the recursion\n        return self.max_path  # Return the maximum path sum found\n```\n\n### Explanation of Code Logic\n\n- **`maxPathSum` Method**: Initializes `self.max_path` to negative infinity, sets up the recursive function `get_max_gain`, and returns the maximum path sum found.\n- **`get_max_gain` Method**: Recursively calculates the maximum gain for each node:\n  - If the node is `None`, returns 0.\n  - Computes gains from the left and right children, ensuring they are at least 0 by using `max(..., 0)`.\n  - Calculates the `current_max_path` which includes the node's value and the gain from both children.\n  - Updates the maximum path sum if the current path sum is greater than the existing maximum.\n  - Returns the maximum gain that can be passed upwards to the parent node.\n\nThis solution efficiently computes the maximum path sum while respecting the constraints of the problem."
          },
          {
                    "title": "valid-palindrome",
                    "solution": "Here’s a clear and concise solution for determining if a given string is a palindrome, while ignoring spaces, punctuation, and letter casing:\n\n### Approach\nWe utilize a two-pointer technique where:\n- One pointer (`left`) starts at the beginning of the string.\n- The other pointer (`right`) starts at the end of the string.\n- Both pointers move toward each other until they meet.\n\nAt each step:\n1. If the character at the `left` pointer is not alphanumeric, we increment `left`.\n2. If the character at the `right` pointer is not alphanumeric, we decrement `right`.\n3. If both characters are alphanumeric, we convert them to lowercase and compare them. If they differ, we return false.\n4. If they are equal, we move both pointers inward.\n\nIf the pointers cross, it means we've successfully checked all relevant characters and the string is a palindrome, so we return true.\n\n### Complexity\n- **Time Complexity:** O(n), where n is the length of the string, because we might check each character at most once.\n- **Space Complexity:** O(1), since we are only using a fixed number of variables.\n\n### Code\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            // Move the left pointer to the next alphanumeric character\n            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {\n                left++;\n            }\n            // Move the right pointer to the previous alphanumeric character\n            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {\n                right--;\n            }\n            // Compare characters\n            if (Character.toLowerCase(s.charAt(left)) != Character.toLowerCase(s.charAt(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n```\n\nThis solution effectively checks if a given string is a palindrome while ignoring non-alphanumeric characters and ensuring case insensitivity."
          },
          {
                    "title": "word-ladder",
                    "solution": "To solve the Word Ladder problem, we need to find the shortest transformation sequence from a starting word to an ending word using only words that are present in a given word list. We can achieve this using the Breadth-First Search (BFS) algorithm because it efficiently explores all potential paths in layers, ensuring that we find the shortest path.\n\nBelow is a concise solution based on the provided explanation and code snippets:\n\n### Python Solution\n\n```python\nfrom collections import deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: list) -> int:\n        wordSet = set(wordList)  # Convert list to set for O(1) lookups\n        if endWord not in wordSet:\n            return 0  # Early exit if endWord is not in wordList\n        \n        queue = deque([(beginWord, 1)])  # Start with beginWord and a length of 1\n        alphabet = 'abcdefghijklmnopqrstuvwxyz'  # Possible characters to replace\n        \n        while queue:\n            current_word, length = queue.popleft()\n            if current_word == endWord:\n                return length  # Return the length of the valid transformation\n            \n            for i in range(len(current_word)):\n                for c in alphabet:\n                    new_word = current_word[:i] + c + current_word[i + 1:]  # Generate new word by changing one letter\n                    if new_word in wordSet:\n                        wordSet.remove(new_word)  # Mark new_word as visited\n                        queue.append((new_word, length + 1))  # Enqueue new word with incremented length\n        \n        return 0  # If we exhaust the queue without finding endWord\n```\n\n### Explanation\n1. **Initialization**:\n    - Convert the `wordList` to a set called `wordSet` for quicker lookups.\n    - Check if `endWord` is present in the `wordSet`. If not, return `0`.\n    - Use a queue (deque) initialized with the `beginWord` and its length `1`.\n  \n2. **BFS Iteration**:\n    - While there are words in the queue:\n        - Dequeue the front element, which gives the current word and its transformation length.\n        - If the current word matches `endWord`, return the length.\n        - Generate all possible transformations of the current word by changing one character at a time. For each transformation:\n            - If the new word exists in `wordSet`, enqueue it and remove it from the set to avoid revisiting.\n\n3. **Return Result**:\n    - If the queue is exhausted without finding the `endWord`, return `0`.\n\n### Complexity Analysis\n- **Time Complexity**: O(M^2 * N), where M is the length of the words and N is the number of words in `wordList`.\n- **Space Complexity**: O(M * N) for storing the characters and the words in the queue and set.\n\nThis approach guarantees that we explore each potential transformation efficiently, ensuring we find the shortest path when possible."
          },
          {
                    "title": "longest-consecutive-sequence",
                    "solution": "Certainly! Below is a clear and concise solution to the problem of finding the longest consecutive sequence in an array of integers. \n\n### Problem Statement\nGiven an unsorted array of integers, find the length of the longest consecutive elements sequence.\n\n### Optimal Solution\nWe can use a HashMap to efficiently track the boundaries of sequences and their lengths as we iterate through the numbers. This approach has a time complexity of O(n) and a space complexity of O(n).\n\n### Python Implementation\n```python\nclass Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        if not nums:  # Handle empty input case\n            return 0\n            \n        num_map = {}  # HashMap to store length of sequences at boundaries\n        max_length = 0\n        \n        for num in nums:\n            if num in num_map:  # Skip duplicates\n                continue\n            \n            left = num_map.get(num - 1, 0)  # Length of the left sequence\n            right = num_map.get(num + 1, 0)  # Length of the right sequence\n            \n            current_length = left + right + 1  # Total length of the new sequence\n            \n            num_map[num] = current_length  # Store length for current number\n            \n            # Extend boundaries of existing sequences\n            num_map[num - left] = current_length  # Update left boundary\n            num_map[num + right] = current_length  # Update right boundary\n            \n            max_length = max(max_length, current_length)  # Update max length\n            \n        return max_length\n```\n\n### Explanation:\n1. **Initialization**: We create a HashMap (`num_map`) to map each number to the length of the longest consecutive sequence it belongs to. We also keep a variable `max_length` to track the maximum length found.\n\n2. **Iterate through numbers**: For each number:\n   - If it has already been processed (exists in the HashMap), we skip it.\n   - We check the left (`num - 1`) and right (`num + 1`) neighbors in the HashMap to find the lengths of existing sequences.\n   - We calculate the current sequence length as `left + right + 1`.\n   - We update the boundaries of the sequences in the HashMap accordingly.\n\n3. **Return the result**: Finally, we return the maximum length found.\n\nThis solution effectively utilizes HashMap operations to ensure that each number is processed only once, achieving optimal performance."
          },
          {
                    "title": "surrounded-regions",
                    "solution": "Here's a clear and concise solution to the problem of surrounded regions, which transforms the 'O's that are surrounded by 'X's into 'X's while leaving the 'O's that are connected to the boundary intact:\n\n```cpp\nclass Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        if (board.empty() || board[0].empty()) return;\n        \n        int m = board.size(), n = board[0].size();\n        \n        // Perform DFS from the boundary\n        for (int i = 0; i < m; i++) {\n            if (board[i][0] == 'O') \n                DFS(board, i, 0);\n            if (board[i][n - 1] == 'O') \n                DFS(board, i, n - 1);\n        }\n        \n        for (int j = 0; j < n; j++) {\n            if (board[0][j] == 'O') \n                DFS(board, 0, j);\n            if (board[m - 1][j] == 'O') \n                DFS(board, m - 1, j);\n        }\n        \n        // Flip all remaining 'O's to 'X's and '#' back to 'O'\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == 'O') \n                    board[i][j] = 'X'; // Flip to 'X'\n                else if (board[i][j] == '#') \n                    board[i][j] = 'O'; // Restore to 'O'\n            }\n        }\n    }\n\nprivate:\n    void DFS(vector<vector<char>>& board, int i, int j) {\n        if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != 'O') return;\n        board[i][j] = '#'; // Mark as visited\n        // Explore all four directions\n        DFS(board, i - 1, j); // up\n        DFS(board, i + 1, j); // down\n        DFS(board, i, j - 1); // left\n        DFS(board, i, j + 1); // right\n    }\n};\n```\n\n### Explanation:\n1. **Boundary Checks**: The solution first traverses the borders of the board to find any 'O's. If it finds 'O's, it performs a Depth-First Search (DFS) to mark all connected 'O's with a temporary marker ('#').\n2. **Flipping Process**:\n   - After marking, the code iterates through the board again and flips any 'O's that remain as 'X' (indicating they are surrounded).\n   - Finally, it changes the '#' markers back to 'O's to restore those that are connected to the boundary.\n3. **DFS Implementation**: The DFS function is defined to traverse and mark all adjacent 'O's. \n\nThis method effectively identifies and preserves the regions of 'O's that are not surrounded by 'X's, ensuring correct output for the problem."
          },
          {
                    "title": "palindrome-partitioning",
                    "solution": "To solve the problem of partitioning a string into all possible palindrome substrings, we can efficiently implement a backtracking algorithm combined with a dynamic programming approach to minimize duplicate checks for palindromes. Below is a clear and concise solution in Java, followed by explanations of the steps involved:\n\n### Java Solution\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public List<List<String>> partition(String s) {\n        List<List<String>> result = new ArrayList<>();\n        boolean[][] dp = new boolean[s.length()][s.length()];\n        \n        // Precompute palindrome substrings\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = 0; j <= i; j++) {\n                if (s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j + 1][i - 1])) {\n                    dp[j][i] = true; // s[j...i] is a palindrome\n                }\n            }\n        }\n        \n        backtrack(result, new ArrayList<>(), dp, s, 0);\n        return result;\n    }\n\n    private void backtrack(List<List<String>> result, List<String> path, boolean[][] dp, String s, int start) {\n        if (start == s.length()) {\n            result.add(new ArrayList<>(path));\n            return;\n        }\n        \n        for (int end = start; end < s.length(); end++) {\n            if (dp[start][end]) {\n                path.add(s.substring(start, end + 1));\n                backtrack(result, path, dp, s, end + 1);\n                path.remove(path.size() - 1); // backtrack\n            }\n        }\n    }\n}\n```\n\n### Explanation of Steps\n1. **Dynamic Programming Table (dp)**:\n   - Create a `boolean` table `dp` where `dp[i][j]` indicates if the substring `s[i...j]` is a palindrome.\n   - Fill the table using a nested loop: If the characters at positions `i` and `j` are the same, check if the substring between them is also a palindrome (using the table itself for quick reference).\n\n2. **Backtracking Function**:\n   - Define a recursive `backtrack` function that explores all valid partitions of the string.\n   - It takes the current starting position, a `path` that contains the current partition, and the results list.\n\n3. **Base Condition**:\n   - If the `start` index reaches the length of the string, it means a complete partitioning has been formed and we can add it to the results.\n\n4. **Exploring Partitions**:\n   - Iterate through the string from the current `start` to the end.\n   - If the substring from `start` to `end` is a palindrome (as indicated by the precomputed `dp` table), add it to the current partition, then recursively call the backtrack function with the updated start index.\n\n5. **Backtrack**:\n   - After exploring one possibility, remove the last added substring (last added partition) to try other options.\n\n### Complexity Analysis\n- **Time Complexity**: O(N^2) for filling the `dp` table and O(2^N) for the backtracking, leading to an overall complexity of O(N^2 + 2^N).\n- **Space Complexity**: O(N^2) for the `dp` table and O(N) for the recursion stack. The overall space complexity is O(N^2).\n\nThis code efficiently finds all possible palindrome partitions for a given string using a combination of dynamic programming to avoid redundant checks, and recursion for exploration through valid partitions."
          },
          {
                    "title": "gas-station",
                    "solution": "Here’s a clear and concise solution to the problem of determining if it's possible to complete a circuit in a gas station array, along with an explanation:\n\n### Problem Summary:\nYou are given two arrays:\n- `gas[i]` - the amount of gas available at the i-th station.\n- `cost[i]` - the amount of gas required to travel from the i-th station to the (i+1)-th station.\n\nThe goal is to determine if there exists a starting gas station index from which you can complete the full circuit, and if so, return that index. If no such index exists, return -1.\n\n### Key Insights:\n1. If the total amount of gas is less than the total cost for the trip, completing the circuit is impossible.\n2. If starting at a certain gas station leads to running out of gas, all stations from the last valid starting point to the current station cannot be starting points either.\n\n### Approach:\nUsing a greedy approach:\n- Keep track of the total surplus of gas (difference between gas available and cost) throughout the journey.\n- Track the current gas surplus during your trip.\n- If the current gas surplus drops below zero, update the starting position to the next station and reset the current surplus.\n\n### Implementation:\n\nHere's the optimized solution in C++:\n\n```cpp\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int total_surplus = 0; // Total surplus gas\n        int current_surplus = 0; // Current gallon of gas in the tank\n        int starting_station = 0; // Index of the starting gas station\n\n        for (int i = 0; i < gas.size(); i++) {\n            total_surplus += gas[i] - cost[i]; // Update total surplus\n            current_surplus += gas[i] - cost[i]; // Update current surplus\n            \n            // If current surplus is negative, reset starting station and current surplus\n            if (current_surplus < 0) {\n                starting_station = i + 1; // Update starting station\n                current_surplus = 0; // Reset current tank\n            }\n        }\n        // If total surplus is negative, it's impossible to complete the circuit\n        return (total_surplus < 0) ? -1 : starting_station;\n    }\n};\n```\n\n### Time Complexity:\n- **O(N)** where N is the number of gas stations. We only make one pass through the lists.\n\n### Space Complexity:\n- **O(1)** as we only use a constant amount of extra space.\n\n### Explanation:\n- We initialize the total surplus and current surplus as zeros. As we iterate through each gas station, we compute the gas available minus the cost.\n- Whenever the current surplus becomes negative, it means that we cannot reach the next station; hence, we update our starting station to the next one and reset the current surplus to zero.\n- Finally, we check if the total surplus is negative to determine if a valid starting gas station exists. If it does not, we return -1. Otherwise, we return the index of the starting station.\n\nThis approach efficiently solves the problem by reducing runtime complexity compared to the brute force method."
          },
          {
                    "title": "single-number",
                    "solution": "The problem is to find the element in an array that appears only once when all other elements appear exactly twice. The solution needs to be efficient in both time and space.\n\n### Solution Approaches:\n\n1. **Using XOR Operator**:\n   - The most efficient way to solve this problem is through the use of the XOR bitwise operator. The properties of XOR tell us that:\n     - `a ^ a = 0` (XOR of two identical numbers is zero)\n     - `a ^ 0 = a` (XOR of any number with zero is the number itself)\n     - XOR is commutative and associative, meaning the order of operations does not matter.\n   \n   Using these properties, if we XOR all the elements in the array, the pairs will cancel each other out, leaving only the unique element.\n\n   **Time Complexity**: O(N)  \n   **Space Complexity**: O(1)\n\n   **Code Example** (C++):\n   ```cpp\n   class Solution {\n   public:\n       int singleNumber(vector<int>& nums) {\n           int result = 0;\n           for (int num : nums) {\n               result ^= num;\n           }\n           return result;\n       }\n   };\n   ```\n\n   **Python Implementation**:\n   ```python\n   class Solution:\n       def singleNumber(self, nums: List[int]) -> int:\n           return functools.reduce(lambda x, y: x ^ y, nums)\n   ```\n\n   **Java Implementation**:\n   ```java\n   class Solution {\n       public int singleNumber(int[] nums) {\n           int result = 0;\n           for (int num : nums) {\n               result ^= num;\n           }\n           return result;\n       }\n   }\n   ```\n\n2. **Using Sorting** (Less Optimal):\n   - First, sort the array. Next, traverse the sorted array comparing adjacent elements. When you encounter an element that is not equal to its neighbor, that's the single element.\n\n   **Time Complexity**: O(N log N) due to sorting  \n   **Space Complexity**: O(1) if the sort is in-place.\n\n   **Code Example**:\n   ```cpp\n   class Solution {\n   public:\n       int singleNumber(vector<int>& nums) {\n           sort(nums.begin(), nums.end());\n           for (int i = 1; i < nums.size(); i += 2) {\n               if (nums[i] != nums[i - 1]) {\n                   return nums[i - 1];\n               }\n           }\n           return nums[nums.size() - 1];\n       }\n   };\n   ```\n\n3. **Using Hash Map** (Not Constant Space):\n   - Store the frequency of each element using a hash map. Iterate over the map to find the element with a frequency of one.\n\n   **Time Complexity**: O(N)  \n   **Space Complexity**: O(N)\n\n   **Code Example**:\n   ```cpp\n   class Solution {\n   public:\n       int singleNumber(vector<int>& nums) {\n           unordered_map<int, int> frequency;\n           for (int num : nums) {\n               frequency[num]++;\n           }\n           for (const auto& pair : frequency) {\n               if (pair.second == 1) {\n                   return pair.first;\n               }\n           }\n           return -1; // Fallback (should not reach here)\n       }\n   };\n   ```\n\n### Conclusion\nFor optimal performance in terms of both time and space, the XOR approach is recommended. It achieves the desired solution with a linear time complexity and constant space usage."
          },
          {
                    "title": "copy-list-with-random-pointer",
                    "solution": "Here's a clear and concise solution for the LeetCode problem of copying a linked list with random pointers, utilizing the in-place interleaving method:\n\n### Problem Overview\nYou are given a linked list where each node has a `.next` pointer to the next node and a `.random` pointer that can point to any node in the list or be `null`. You need to return a deep copy of the list, ensuring that the new nodes do not reference the nodes in the original list.\n\n### Solution Approach\nWe can solve this problem using a three-step approach while maintaining O(1) space complexity.\n\n### Steps\n1. **Interleaving Nodes**: For each node in the original list, create a copy and insert it directly after the original node. This transforms the list from `A->B->C` to `A->A'->B->B'->C->C'`.\n\n2. **Assigning Random Pointers**: Iterate through the interleaved list and set the random pointers for the copied nodes using the rule:\n   ```\n   old_node.next.random = old_node.random.next\n   ```\n\n3. **Separating the Lists**: Restore the original list while creating the copied list. This involves unlinking the copied nodes from the original ones.\n\n### Final Code\n\nHere is the implementation in Python:\n\n```python\nclass Node:\n    def __init__(self, val=0, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n\nclass Solution:\n    def copyRandomList(self, head: 'Node') -> 'Node':\n        if not head:\n            return None\n        \n        # Step 1: Interleave original and copied nodes\n        curr = head\n        while curr:\n            new_node = Node(curr.val)\n            new_node.next = curr.next\n            curr.next = new_node\n            curr = new_node.next\n\n        # Step 2: Assign random pointers for the copied nodes\n        curr = head\n        while curr:\n            if curr.random:\n                curr.next.random = curr.random.next\n            curr = curr.next.next  # Move to the next original node\n\n        # Step 3: Separate the copied list from the original\n        old_head = head\n        new_head = head.next\n        curr_old = old_head\n        curr_new = new_head\n\n        while curr_old:\n            curr_old.next = curr_old.next.next  # Restore the original list\n            curr_new.next = curr_new.next.next if curr_new.next else None  # Prepare next copied node\n            curr_old = curr_old.next\n            curr_new = curr_new.next\n\n        return new_head  # Return the head of the copied list\n```\n\n### Complexity Analysis\n- **Time Complexity**: O(n), where n is the number of nodes in the linked list, since we iterate over the list a constant number of times (three times).\n- **Space Complexity**: O(1), as we are not using any additional data structures that scale with the input size.\n\nThis method efficiently solves the problem with optimal use of space while maintaining clarity in the logic."
          },
          {
                    "title": "word-break",
                    "solution": "Here's a clear and concise solution for the \"Word Break\" problem using dynamic programming in Java:\n\n```java\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nclass Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordSet = new HashSet<>(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && wordSet.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n\n        return dp[s.length()];\n    }\n}\n```\n\n### Explanation:\n1. We create a set of words for fast lookup from the `wordDict`.\n2. We define a boolean array `dp` where `dp[i]` will be `true` if the substring `s[0:i]` can be segmented into words from the dictionary.\n3. We initialize `dp[0]` to `true` because an empty string can always be segmented.\n4. We iterate through the string `s` with two nested loops:\n   - The outer loop iterates over the end index `i`.\n   - The inner loop checks each substring ending at `i` by looking back to each possible starting index `j`.\n5. If we find `dp[j]` is `true` and the substring `s[j:i]` is in the dictionary, we mark `dp[i]` as `true`.\n6. Finally, we return `dp[s.length()]`, which indicates if the entire string can be segmented.\n\n### Time Complexity:\nThe time complexity is O(n^2) where n is the length of the string, as we may check every possible substring for each end index. The space complexity is O(n) due to the `dp` array."
          },
          {
                    "title": "word-break-ii",
                    "solution": "Here's a clear and concise solution to the Word Break II problem based on the provided user solutions:\n\n**Java Solution:**\n```java\nimport java.util.*;\n\nclass Solution {\n    private Map<String, List<String>> memo;\n\n    public List<String> wordBreak(String s, Set<String> wordDict) {\n        memo = new HashMap<>();\n        return helper(s, wordDict);\n    }\n\n    private List<String> helper(String s, Set<String> wordDict) {\n        // Check if the result is already computed\n        if (memo.containsKey(s)) {\n            return memo.get(s);\n        }\n        \n        List<String> res = new ArrayList<>();\n        // If the string is empty, return a list containing an empty string\n        if (s.isEmpty()) {\n            res.add(\"\");\n            return res;\n        }\n        \n        // Iterate through all words in the dictionary\n        for (String word : wordDict) {\n            // Check if the current string starts with the word\n            if (s.startsWith(word)) {\n                // Recur for the remaining substring\n                List<String> sublist = helper(s.substring(word.length()), wordDict);\n                // Build the sentences\n                for (String sub : sublist) {\n                    res.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);\n                }\n            }\n        }\n        \n        // Store the result in the memoization map and return\n        memo.put(s, res);\n        return res;\n    }\n}\n```\n\n**Python Solution:**\n```python\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        memo = {}\n        \n        def backtrack(start):\n            # Check if the result is already computed\n            if start in memo:\n                return memo[start]\n            if start == len(s):\n                return [\"\"]  # Base case: empty string\n            \n            res = []\n            for word in wordDict:\n                # If the current prefix matches the word, backtrack\n                if s.startswith(word, start):\n                    for sub in backtrack(start + len(word)):\n                        # Build the sentence\n                        res.append(word + (\"\" if sub == \"\" else \" \" + sub))\n            memo[start] = res\n            return res\n            \n        return backtrack(0)\n```\n\n**Explanation:**\n- Both solutions utilize recursive DFS with memoization to efficiently build all possible sentences.\n- We maintain a cache (`memo`) to store results for each substring already computed.\n- The base case is when an empty substring is reached, returning a list with an empty string.\n- For each word in the dictionary, we check if it can be the prefix of the current substring and recursively call the helper function on the remainder.\n- Finally, we combine valid prefixes with results from the recursive calls to construct full sentences."
          },
          {
                    "title": "linked-list-cycle",
                    "solution": "The problem at hand is to determine whether a given singly-linked list contains a cycle. To solve this, we can employ Floyd's Cycle-Finding Algorithm using the two-pointer technique. Here's a clear and concise solution with an explanation:\n\n### Solution\n\n```java\nclass Solution {\n    public boolean hasCycle(ListNode head) {\n        // Initialize two pointers: slow and fast\n        ListNode slow = head;\n        ListNode fast = head;\n\n        // Traverse the list\n        while (fast != null && fast.next != null) {\n            // Move slow pointer by one step\n            slow = slow.next;\n            // Move fast pointer by two steps\n            fast = fast.next.next;\n\n            // If they meet at the same node, a cycle exists\n            if (slow == fast) {\n                return true;\n            }\n        }\n\n        // If fast pointer reaches the end, no cycle exists\n        return false;\n    }\n}\n```\n\n### Explanation\n\n1. **Two Pointers**:\n   - We maintain two pointers, `slow` and `fast`. The `slow` pointer moves one step at a time, whereas the `fast` pointer moves two steps at a time.\n\n2. **Cycle Detection**:\n   - As we traverse the linked list, if there is a cycle, the `fast` pointer will eventually catch up to the `slow` pointer. This is because the `fast` pointer, moving at a higher speed, will loop around and meet the `slow` pointer within the cycle.\n\n3. **Traversal**:\n   - The traversal continues until the `fast` pointer reaches the end of the list (`null`). If this occurs, it indicates that there is no cycle.\n\n### Complexity Analysis\n- **Time Complexity**: O(N), where N is the number of nodes in the linked list. In the worst case, we may need to traverse all nodes.\n- **Space Complexity**: O(1), since we are using a constant amount of space for the two pointers.\n\n### Conclusion\nThis algorithm effectively determines whether the linked list has a cycle in a time-efficient manner while using minimal additional space, making it a highly preferable method for this problem."
          },
          {
                    "title": "lru-cache",
                    "solution": "The problem is to implement an LRU (Least Recently Used) Cache. Below is a clear and concise implementation of the LRU Cache in Java, Python, and C++:\n\n### Java Implementation\n```java\nimport java.util.HashMap;\n\nclass LRUCache {\n    private class Node {\n        int key, value;\n        Node prev, next;\n\n        Node(int k, int v) {\n            this.key = k;\n            this.value = v;\n        }\n    }\n\n    private final int capacity;\n    private int count;\n    private HashMap<Integer, Node> map;\n    private Node head, tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.count = 0;\n        this.map = new HashMap<>();\n        \n        head = new Node(0, 0);\n        tail = new Node(0, 0);\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    private void remove(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void addToHead(Node node) {\n        node.next = head.next;\n        head.next.prev = node;\n        node.prev = head;\n        head.next = node;\n    }\n\n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            remove(node);\n            addToHead(node);\n            return node.value;\n        }\n        return -1;\n    }\n\n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            remove(node);\n            node.value = value;\n            addToHead(node);\n        } else {\n            if (count == capacity) {\n                Node lru = tail.prev;\n                remove(lru);\n                map.remove(lru.key);\n                count--;\n            }\n            Node newNode = new Node(key, value);\n            addToHead(newNode);\n            map.put(key, newNode);\n            count++;\n        }\n    }\n}\n```\n\n### Python Implementation\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.data = OrderedDict()\n\n    def get(self, key: int) -> int:\n        if key not in self.data:\n            return -1\n        else:\n            self.data.move_to_end(key)  # Move the accessed item to the end\n            return self.data[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.data:\n            self.data.move_to_end(key)  # Move the accessed item to the end\n        self.data[key] = value  # Update the value\n        if len(self.data) > self.capacity:\n            self.data.popitem(last=False)  # Pop the first item (least recently used)\n```\n\n### C++ Implementation\n```cpp\n#include <unordered_map>\n#include <list>\n\nclass LRUCache {\nprivate:\n    int capacity;\n    std::list<std::pair<int, int>> cache;  // key-value pair\n    std::unordered_map<int, std::list<std::pair<int, int>>::iterator> map;  // key to iterator\n\npublic:\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n    }\n\n    int get(int key) {\n        auto it = map.find(key);\n        if (it == map.end()) {\n            return -1;  // Key not found\n        }\n        // Move the accessed key-value pair to the front\n        cache.splice(cache.begin(), cache, it->second);\n        return it->second->second;  // Return the value\n    }\n\n    void put(int key, int value) {\n        auto it = map.find(key);\n        if (it != map.end()) {\n            // Key already exists, update the value\n            it->second->second = value;\n            cache.splice(cache.begin(), cache, it->second);\n        } else {\n            // Key does not exist, insert a new key-value pair\n            if (cache.size() == capacity) {\n                // Remove the least recently used item\n                int lru_key = cache.back().first;\n                cache.pop_back();\n                map.erase(lru_key);\n            }\n            cache.emplace_front(key, value);\n            map[key] = cache.begin();  // Store the new iterator\n        }\n    }\n};\n```\n\nThese implementations utilize a hashmap for O(1) access times, and a doubly linked list to maintain the order of usage for the LRU caching mechanism."
          },
          {
                    "title": "sort-list",
                    "solution": "Here is a clear and concise implementation of the solution to the LeetCode problem **Sort List** using the merge sort algorithm. This approach utilizes the bottom-up method to achieve **O(n log n)** time complexity and **O(1)** space complexity.\n\n### Implementation in Java:\n\n```java\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n\n        int length = getLength(head);\n        for (int step = 1; step < length; step *= 2) {\n            ListNode cur = dummy.next;\n            ListNode tail = dummy;\n\n            while (cur != null) {\n                ListNode left = cur; // Start of the first half\n                ListNode right = split(left, step); // Start of the second half\n                cur = split(right, step); // Move cur forward\n\n                // Merge the two halves\n                tail = merge(left, right, tail);\n            }\n        }\n        return dummy.next;\n    }\n\n    private int getLength(ListNode head) {\n        int length = 0;\n        While (head != null) {\n            length++;\n            head = head.next;\n        }\n        return length;\n    }\n\n    private ListNode split(ListNode head, int n) {\n        for (int i = 1; head != null && i < n; i++) {\n            head = head.next;\n        }\n        if (head == null) return null;\n\n        ListNode second = head.next;\n        head.next = null; // Cut the list\n        return second;\n    }\n\n    private ListNode merge(ListNode l1, ListNode l2, ListNode tail) {\n        ListNode cur = tail;\n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        cur.next = (l1 != null) ? l1 : l2;\n        while (cur.next != null) {\n            cur = cur.next;\n        }\n        return cur;\n    }\n}\n```\n\n### Explanation:\n1. **Initialization**: The `sortList` method starts by checking if the linked list is either empty or has only one node. If true, it returns `head` as it is considered sorted.\n\n2. **Getting Length**: The `getLength` method computes the length of the linked list which is crucial for the merge sort procedure.\n\n3. **Merging in Pairs**:\n    - The process involves splitting the linked list into pairs of sorted lists, merging them back together until the entire list is sorted.\n    - The `split` method handles the division of the linked list into two parts based on the given length.\n\n4. **Merging Functionality**: \n    - The `merge` method takes two sorted linked lists and merges them into a single sorted linked list. It maintains a dummy node to simplify the merging process.\n\nThis solution effectively sorts the linked list while adhering to the specified space and time complexity requirements.\n"
          },
          {
                    "title": "max-points-on-a-line",
                    "solution": "Here is a concise and clear solution based on the provided approaches to the \"Max Points on a Line\" problem:\n\n```java\nclass Solution {\n    public int maxPoints(Point[] points) {\n        if (points == null || points.length == 0) return 0;\n        if (points.length <= 2) return points.length;\n        \n        int maxPoints = 2;\n        for (int i = 0; i < points.length; i++) {\n            Map<Double, Integer> slopeMap = new HashMap<>();\n            int samePoint = 1;\n            for (int j = i + 1; j < points.length; j++) {\n                if (points[i].x == points[j].x && points[i].y == points[j].y) {\n                    samePoint++;\n                    continue;\n                }\n                double slope = (points[j].x == points[i].x) ? Double.POSITIVE_INFINITY :\n                               (double)(points[j].y - points[i].y) / (points[j].x - points[i].x);\n                slopeMap.put(slope, slopeMap.getOrDefault(slope, 0) + 1);\n            }\n            int maxSameSlope = samePoint;\n            for (int count : slopeMap.values()) {\n                maxSameSlope = Math.max(maxSameSlope, count + samePoint);\n            }\n            maxPoints = Math.max(maxPoints, maxSameSlope);\n        }\n        return maxPoints;\n    }\n}\n```\n\n### Explanation:\n1. **Input Handling:** The function first checks if the input is empty or has less than two points.\n2. **Slope Calculation:** For every point, it calculates the slope to every other point using a hashmap to keep track of how many points share that slope with the current point.\n3. **Handling Duplicates:** If points are identical, it increments a counter to account for overlapping points.\n4. **Finding Max Points:** For each slope calculated, it updates the maximum count of points on the same line by including the count of same points.\n5. **Final Output:** After all calculations, it returns the maximum number of points that lie on the same line.\n\n### Complexity:\n- **Time Complexity:** O(n^2) due to nested loops for slope calculation.\n- **Space Complexity:** O(n) for storing slopes in the hashmap. \n\nThis implementation efficiently calculates the maximum number of points that lie on the same straight line with clear logic and concise code."
          },
          {
                    "title": "evaluate-reverse-polish-notation",
                    "solution": "Here is a clear and concise solution for evaluating Reverse Polish Notation (RPN) using a stack in C++, Java, and Python:\n\n### C++ Solution\n```cpp\n#include <vector>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <functional>\n\nclass Solution {\npublic:\n    int evalRPN(std::vector<std::string>& tokens) {\n        std::stack<int> stack;\n        for (const std::string& token : tokens) {\n            if (isdigit(token[0]) || (token.size() > 1 && token[0] == '-')) {\n                stack.push(std::stoi(token));\n            } else {\n                int op2 = stack.top(); stack.pop();\n                int op1 = stack.top(); stack.pop();\n                if (token == \"+\") stack.push(op1 + op2);\n                else if (token == \"-\") stack.push(op1 - op2);\n                else if (token == \"*\") stack.push(op1 * op2);\n                else if (token == \"/\") stack.push(op1 / op2);\n            }\n        }\n        return stack.top();\n    }\n};\n```\n\n### Java Solution\n```java\nimport java.util.Stack;\n\npublic class Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n        for (String token : tokens) {\n            switch (token) {\n                case \"+\":\n                    stack.push(stack.pop() + stack.pop());\n                    break;\n                case \"-\":\n                    int b = stack.pop();\n                    int a = stack.pop();\n                    stack.push(a - b);\n                    break;\n                case \"*\":\n                    stack.push(stack.pop() * stack.pop());\n                    break;\n                case \"/\":\n                    b = stack.pop();\n                    a = stack.pop();\n                    stack.push(a / b);\n                    break;\n                default:\n                    stack.push(Integer.parseInt(token));\n            }\n        }\n        return stack.pop();\n    }\n}\n```\n\n### Python Solution\n```python\nclass Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                op2 = stack.pop()\n                op1 = stack.pop()\n                if token == \"+\":\n                    stack.append(op1 + op2)\n                elif token == \"-\":\n                    stack.append(op1 - op2)\n                elif token == \"*\":\n                    stack.append(op1 * op2)\n                elif token == \"/\":\n                    stack.append(int(op1 / op2))  # use int() to handle integer division\n            else:\n                stack.append(int(token))\n        return stack.pop()\n```\n\n### Explanation\n1. **Data Structure**: All three implementations use a stack to hold numbers.\n2. **Processing Tokens**: For each token:\n   - If it's a number, push it onto the stack.\n   - If it's an operator (+, -, *, /), pop the top two numbers from the stack, perform the operation, and push the result back onto the stack.\n3. **Final Result**: After processing all tokens, the final result will be at the top of the stack.\n\n### Complexity\n- **Time Complexity**: O(N), where N is the number of tokens.\n- **Space Complexity**: O(N) for the stack in the worst case. Each of the methods can be optimized further based on specific use cases (for example, using the input array as a stack in C++ if allowed)."
          },
          {
                    "title": "maximum-product-subarray",
                    "solution": "Here is a clear and concise solution to the problem of finding the maximum product of a contiguous subarray, utilizing an optimal approach based on Kadane's Algorithm:\n\n```cpp\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        if (nums.empty()) return 0;\n\n        // Initialize the max and min products up to the first element\n        int maxProd = nums[0], minProd = nums[0], result = nums[0];\n\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i] < 0) { // If the current number is negative, swap max and min\n                swap(maxProd, minProd);\n            }\n            // Update the max and min products\n            maxProd = max(nums[i], maxProd * nums[i]);\n            minProd = min(nums[i], minProd * nums[i]);\n\n            // Update the result with the maximum product found so far\n            result = max(result, maxProd);\n        }\n        \n        return result;\n    }\n};\n```\n\n### Explanation:\n1. **Initialization**: Start with the first element as both the maximum and minimum product, as well as the result.\n2. **Iteration**:\n   - For each subsequent element:\n     - If it's negative, swap `maxProd` and `minProd` since multiplying by a negative number will turn the maximum product into a minimum product and vice versa.\n     - Update `maxProd` and `minProd` using the current element.\n3. **Result Update**: Compare the current `maxProd` with the global maximum found so far (`result`), and update accordingly.\n4. **Return**: Finally, return the result which contains the maximum product of any contiguous subarray. \n\n### Complexity:\n- **Time Complexity**: O(N), where N is the number of elements in the array, since we traverse the array only once.\n- **Space Complexity**: O(1), as we are using a constant amount of space for the variables.\n\nThis solution effectively handles arrays containing positive numbers, negative numbers, and zeros, ensuring optimal performance and clarity."
          },
          {
                    "title": "min-stack",
                    "solution": "Here is a clear and concise solution for the MinStack class that efficiently tracks the minimum element in the stack. This solution uses a single stack that stores pairs of integers: the current value and the minimum value up to that point.\n\n```java\nclass MinStack {\n    private List<Pair<Integer, Integer>> stack;\n\n    public MinStack() {\n        stack = new ArrayList<>();\n    }\n\n    public void push(int val) {\n        if (stack.isEmpty()) {\n            stack.add(new Pair<>(val, val));\n        } else {\n            int currentMin = Math.min(val, stack.get(stack.size() - 1).getValue());\n            stack.add(new Pair<>(val, currentMin));\n        }\n    }\n\n    public void pop() {\n        stack.remove(stack.size() - 1);\n    }\n\n    public int top() {\n        return stack.get(stack.size() - 1).getKey();\n    }\n\n    public int getMin() {\n        return stack.get(stack.size() - 1).getValue();\n    }\n}\n```\n\n### Explanation:\n- **Data Structure**: We use an `ArrayList` to simulate the stack where each entry is a `Pair` consisting of the current value and the minimum value at that moment.\n- **Push Operation**: When pushing a value, we compare it with the current minimum (found in the last element of the stack) and store the smaller of the two as the new minimum.\n- **Pop Operation**: Simply remove the last element of the stack.\n- **Top Operation**: Retrieve the value of the last element in the stack.\n- **GetMin Operation**: Retrieve the minimum value stored with the last element.\n\n### Time Complexity:\n- All operations (push, pop, top, getMin) run in O(1) time.\n\n### Space Complexity:\n- The space complexity is O(N) due to the storage of pairs for each element pushed onto the stack."
          },
          {
                    "title": "intersection-of-two-linked-lists",
                    "solution": "Here's a clear and concise solution to the LeetCode problem of finding the intersection of two linked lists. The solution utilizes the Two-Pointer technique, which effectively manages pointers for both lists to handle potential length discrepancies without using extra space.\n\n### Solution: Two-Pointer Method\n\nThis approach runs in O(m + n) time and O(1) space, making it efficient for large inputs.\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA, b = headB;\n\n        // Continue until both pointers meet at the intersection or at the end (null)\n        while (a != b) {\n            // If one pointer reaches the end, switch to the head of the other list\n            a = (a == null) ? headB : a.next;\n            b = (b == null) ? headA : b.next;\n        }\n\n        // Either both are null (no intersection) or they meet at the intersection point\n        return a;\n    }\n}\n```\n\n### Explanation:\n\n1. **Pointers Initialization**: Two pointers (`a` for `headA` and `b` for `headB`) are initialized.\n  \n2. **Traversing the Lists**: \n   - Move both pointers at the same time. If one pointer reaches the end of its list, switch it to the head of the other list.\n   - This switching effectively normalizes the length difference, ensuring that both pointers traverse an equal distance by the time they meet (if they intersect).\n  \n3. **Loop Condition**: The loop continues until the pointers point to the same node (intersection) or both reach the end (null).\n  \n4. **Return Result**: The function returns the meeting node or null if there is no intersection.\n\nThis method is intuitive and avoids the use of additional data structures like hash maps, making it space efficient."
          },
          {
                    "title": "find-peak-element",
                    "solution": "Here's a concise solution that covers the problem of finding a peak element in an array using binary search, along with explanations for both iterative and recursive approaches:\n\n### Problem Statement:\nGiven an array of integers, a peak element is defined as an element that is greater than its neighbors. For edge elements, we only consider one neighbor. The task is to find any peak element.\n\n### Solution\nWe can utilize binary search due to the properties of the array. A peak element may not be unique, and there can be multiple peak elements.\n\n#### Iterative Binary Search:\n```cpp\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        int low = 0, high = nums.size() - 1;\n\n        while (low < high) {\n            int mid = (low + high) / 2;\n            // Compare mid with its right neighbor\n            if (nums[mid] < nums[mid + 1]) {\n                // If mid is less than the right neighbor, then a peak must be on the right side\n                low = mid + 1;\n            } else {\n                // If mid is greater than the right neighbor, then a peak must be on the left side (including mid)\n                high = mid;\n            }\n        }\n        // At the end of the loop, low == high, which is a peak element\n        return low;\n    }\n};\n```\n\n#### Recursive Binary Search:\n```cpp\nclass Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        return peakUtil(nums, 0, nums.size() - 1);\n    }\n\nprivate:\n    int peakUtil(vector<int>& nums, int low, int high) {\n        // Base case when there's a single element left, return its index\n        if (low == high) return low;\n\n        int mid = (low + high) / 2;\n\n        // Compare mid with its right neighbor\n        if (nums[mid] < nums[mid + 1]) {\n            // If mid is less than the right neighbor, go right\n            return peakUtil(nums, mid + 1, high);\n        } else {\n            // If mid is greater than the right neighbor, go left\n            return peakUtil(nums, low, mid);\n        }\n    }\n};\n```\n\n### Explanation:\n1. **Iterative Approach:**\n   - We maintain two pointers, `low` and `high`, which represent the current search space. \n   - The `mid` is compared with its right neighbor to make decisions about which half of the array to continue searching in.\n   - This continues until `low` and `high` converge, at which point we've identified a peak element.\n\n2. **Recursive Approach:**\n   - The recursive function performs similar comparisons as the iterative version but uses stack calls to manage state rather than using explicit pointers.\n   - The base case is when the `low` pointer meets `high`, indicating a single element left, which is returned as a peak.\n\n### Time Complexity:\nBoth approaches run in O(log N) time due to the halving of the search space in each step.\n\n### Space Complexity:\n- Iterative: O(1) space complexity since we are using constant space.\n- Recursive: O(log N) space complexity due to the call stack in recursion.\n\nThis concise implementation should provide a clear solution for finding a peak element in an integer array using both iterative and recursive binary search approaches."
          },
          {
                    "title": "fraction-to-recurring-decimal",
                    "solution": "Here is a clear and concise solution to the problem of converting a fraction to its decimal representation, handling repeating decimals appropriately:\n\n```cpp\nclass Solution {\npublic:\n    string fractionToDecimal(int numerator, int denominator) {\n        // Handle the case for zero numerator\n        if (numerator == 0) return \"0\";\n        \n        string result;\n        \n        // Determine the sign of the result\n        if (numerator > 0 ^ denominator > 0) result += '-';\n        \n        // Work with long to handle overflow cases\n        long num = labs(numerator), den = labs(denominator);\n        \n        // Append the integral part\n        result += to_string(num / den);\n        \n        // Calculate the initial remainder\n        long remainder = num % den;\n        if (remainder == 0) return result; // No fractional part\n        \n        result += '.'; // Append decimal point\n        \n        // Create a map to track the position of remainders\n        unordered_map<long, int> remainderMap;\n        \n        // Simulate the division process\n        while (remainder != 0) {\n            // If we have seen this remainder before, a repeating fraction exists\n            if (remainderMap.find(remainder) != remainderMap.end()) {\n                result.insert(remainderMap[remainder], \"(\");\n                result += ')';\n                break;\n            }\n            remainderMap[remainder] = result.size(); // Store the position of this remainder\n            \n            // Update the remainder for the next digit\n            remainder *= 10;\n            result += to_string(remainder / den);\n            remainder %= den;\n        }\n        \n        return result;\n    }\n};\n```\n\n### Explanation:\n1. **Zero Numerator**: If the numerator is zero, simply return \"0\".\n2. **Sign Handling**: Determine the sign of the result. If one of them (numerator or denominator) is negative but not both, prepend a '-' sign.\n3. **Long for Overflow**: Convert both `numerator` and `denominator` to long to prevent overflow when performing division.\n4. **Integral Part**: Calculate and append the integral part of the division.\n5. **Remainder Tracking**: Use a map (`unordered_map`) to keep track of previously seen remainders and their positions in the result string.\n6. **Fractional Calculation**: Multiply the remainder by 10 to simulate long division, appending each resulting digit to the result string.\n7. **Detecting Repeats**: If a remainder repeats, insert parentheses at the appropriate position and finalize the result.\n\n### Edge Cases:\n- Handles negative results.\n- Can manage large integers and prevent overflow by utilizing `long`.\n- Properly handles scenarios with no fractional part or with repeating decimals. \n\nThis solution efficiently converts a fraction into its decimal representation while properly handling signing and repeating decimals."
          },
          {
                    "title": "majority-element",
                    "solution": "Here is a clear and concise solution that combines all the approaches discussed for finding the majority element in an array:\n\n### Problem\nGiven an array of size `n`, find the element that appears more than `n/2` times. It is guaranteed that such an element always exists in the array.\n\n### Solutions\n\n#### 1. Moore's Voting Algorithm\nThis algorithm works in O(n) time complexity and O(1) space complexity. It maintains a count of the candidate for majority element and its frequency.\n\n```cpp\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int count = 0, candidate = 0;\n        for (int num : nums) {\n            if (count == 0) {\n                candidate = num;\n            }\n            count += (num == candidate) ? 1 : -1;\n        }\n        return candidate;\n    }\n};\n```\n\n#### 2. HashMap Approach\nThis method uses a hash map to count occurrences of each element. If any element's count exceeds `n/2`, it returns that element.\n\n```cpp\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        unordered_map<int, int> countMap;\n        for (int num : nums) {\n            if (++countMap[num] > nums.size() / 2) {\n                return num;\n            }\n        }\n        return 0;  // This line won't be reached since a majority element is guaranteed to exist.\n    }\n};\n```\n\n#### 3. Sorting\nBy sorting the array, the majority element will always be at the index `n/2`. This takes O(n log n) time, but it's a simple solution.\n\n```cpp\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        return nums[nums.size() / 2];\n    }\n};\n```\n\n### Conclusion\nAmong the approaches, Moore's Voting Algorithm is the most efficient with linear time complexity and constant space complexity, making it the preferred method for solving this problem. The HashMap approach is also efficient but consumes more space. Sorting is the simplest intuitive method but has a higher time complexity. Choose the approach based on your requirements and constraints."
          },
          {
                    "title": "excel-sheet-column-number",
                    "solution": "Here's a clear and concise solution to the LeetCode problem **171. Excel Sheet Column Number** based on the provided user's insights:\n\n## Problem Statement\nGiven a string `columnTitle` that represents the column title as appear in an Excel sheet, return its corresponding column number.\n\n## Explanation\n- Each letter corresponds to a numerical value: 'A' = 1, 'B' = 2, ..., 'Z' = 26.\n- Columns are indexed like a base-26 numeral system, where each subsequent letter signifies a higher place value:\n  - For example:\n    - \"A\" → 1\n    - \"Z\" → 26\n    - \"AA\" → 27 (1 * 26 + 1)\n    - \"AB\" → 28 (1 * 26 + 2)\n- For a string of length `n`, the conversion involves iterating through each character, converting it to its respective number, and calculating its contribution based on its position.\n\n## Solution Code\n\nHere is the implementation in Python, Java, and C++:\n\n### Python\n```python\nclass Solution:\n    def titleToNumber(self, columnTitle: str) -> int:\n        ans = 0\n        for c in columnTitle:\n            ans = ans * 26 + (ord(c) - ord('A') + 1)\n        return ans\n```\n\n### Java\n```java\nclass Solution {\n    public int titleToNumber(String columnTitle) {\n        int result = 0;\n        for (char c : columnTitle.toCharArray()) {\n            result = result * 26 + (c - 'A' + 1);\n        }\n        return result;\n    }\n}\n```\n\n### C++\n```cpp\nclass Solution {\npublic:\n    int titleToNumber(string columnTitle) {\n        int result = 0;\n        for (char c : columnTitle) {\n            result = result * 26 + (c - 'A' + 1);\n        }\n        return result;\n    }\n};\n```\n\n## Complexity\n- **Time Complexity**: O(n), where n is the length of the column title.\n- **Space Complexity**: O(1), since no additional data structures are used.\n\nThis solution performs a single pass through the input string to compute the final column number efficiently."
          },
          {
                    "title": "factorial-trailing-zeroes",
                    "solution": "To solve the problem of counting trailing zeroes in the factorial of a number `n`, we can utilize the fact that trailing zeroes are produced by the factor 10, which is the product of factors 2 and 5. Since factors of 2 are always more abundant than factors of 5, the task reduces to counting how many times 5 can be a factor in the numbers from 1 to `n`.\n\nHere's a clear and concise approach to compute the trailing zeroes in `n!`:\n\n### Steps:\n1. Count how many multiples of 5 are present from 1 to `n` (each contributes at least one factor of 5).\n2. Count how many multiples of 25 are present (these contribute an extra factor of 5).\n3. Count how many multiples of 125 are present, and so on, until the multiple exceeds `n`.\n\nThis can be represented in a loop where we repeatedly divide `n` by 5 (and its powers) and accumulate the results:\n\n### Final Implementation:\nHere are implementations in Java, C++, and Python:\n\n#### Java:\n```java\npublic class Solution {\n    public int trailingZeroes(int n) {\n        int count = 0;\n        while (n > 0) {\n            n /= 5;\n            count += n;\n        }\n        return count;\n    }\n}\n```\n\n#### C++:\n```cpp\nclass Solution {\npublic:\n    int trailingZeroes(int n) {\n        int count = 0;\n        while (n > 0) {\n            n /= 5;\n            count += n;\n        }\n        return count;\n    }\n};\n```\n\n#### Python:\n```python\nclass Solution:\n    def trailingZeroes(self, n: int) -> int:\n        count = 0\n        while n > 0:\n            n //= 5\n            count += n\n        return count\n```\n\n### Explanation of the Code:\n- We initialize a variable `count` to keep track of the number of trailing zeroes.\n- Using a loop, we divide `n` by 5 repeatedly until `n` becomes zero. In each iteration, we add `n/5` (integer division) to `count`.\n- The loop effectively counts all contributions from multiples of 5, 25, 125, etc., which correspond to the needed factors of 5.\n\n### Complexity:\n- **Time Complexity**: O(log_5(n)) — Since we're dividing `n` by 5 in each iteration.\n- **Space Complexity**: O(1) — We are using a constant amount of space.\n\nThis method is efficient and avoids issues related to integer overflow by using integer division directly without constructing the factorial explicitly."
          },
          {
                    "title": "largest-number",
                    "solution": "Here is a clear and concise solution for the problem of forming the largest number from a list of integers. \n\n**Problem Statement:**\nGiven a list of non-negative integers, rearrange them such that they form the largest number possible. The result is returned as a string.\n\n**Solution:**\nWe can solve this by converting the integers to strings and sorting them based on the order of their concatenation. Specifically, for two numbers represented as strings `x` and `y`, we will compare `x + y` and `y + x`. If `x + y` is larger, `x` should come before `y` in the sorted order.\n\nHere is a Python implementation using a custom comparison function:\n\n```python\nfrom functools import cmp_to_key\n\nclass Solution:\n    def largestNumber(self, nums):\n        # Convert all integers to strings\n        nums = [str(num) for num in nums]\n        \n        # Custom sorting function based on concatenation\n        def compare(x, y):\n            # Compare combined strings\n            return (y + x > x + y) - (y + x < x + y)\n        \n        # Sort nums using the custom comparator\n        nums.sort(key=cmp_to_key(compare))\n        \n        # Join numbers to form the largest number and remove leading zeros\n        largest_num = ''.join(nums).lstrip('0')\n        \n        # Edge case: if the result is empty, it means the largest number is 0\n        return largest_num if largest_num else '0'\n```\n\n### Explanation:\n1. **String Conversion:** Convert each number in the input list to a string for comparison.\n2. **Custom Sorting:** Define a comparison function that will decide the order based on the concatenated results of two strings.\n3. **Sorting Logic:** Sort the list of strings in such a way that the concatenated result `x + y` is compared with `y + x`. This ensures that the larger concatenation comes first.\n4. **Final Composition:** Join the sorted list into one string and eliminate any leading zeros.\n5. **Return Result:** Return the resulting string. If the string is empty after removing leading zeros, return `'0'`.\n\nThis algorithm efficiently constructs the largest number and handles edge cases like multiple zeros correctly. The time complexity is `O(n log n)` due to sorting, where `n` is the number of elements in the input list. The space complexity is `O(n)` for storing the string representations."
          },
          {
                    "title": "rotate-array",
                    "solution": "Here's a concise and clear solution to the problem of rotating an array to the right by `k` steps. The optimized approach involves reversing segments of the array:\n\n```java\npublic class Solution {\n    public void rotate(int[] nums, int k) {\n        if (nums.length < 2) return; // No rotation needed for array with less than 2 elements\n        \n        k = k % nums.length; // Handle cases where k is larger than array length\n        \n        // Step 1: Reverse the first part (0 to n-k-1)\n        reverse(nums, 0, nums.length - k - 1);\n        // Step 2: Reverse the second part (n-k to n-1)\n        reverse(nums, nums.length - k, nums.length - 1);\n        // Step 3: Reverse the whole array\n        reverse(nums, 0, nums.length - 1);\n    }\n    \n    private void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n```\n\n### Explanation:\n\n1. **Check if an array rotation is necessary:** If the length of the array is less than 2, there’s no need for rotation.\n\n2. **Normalize `k`:** Use `k % nums.length` to accommodate cases where `k` is larger than the array length.\n\n3. **Reverse Operations:**\n   - **Reverse the first part** (from the start of the array up to `n-k-1`).\n   - **Reverse the second part** (from `n-k` to the end of the array).\n   - **Reverse the entire array** to achieve the desired rotated order.\n\n### Complexity:\n- **Time Complexity:** O(n), where n is the number of elements in the array.\n- **Space Complexity:** O(1), as the operations are performed in place without needing extra space.\n\nThis method is efficient and straightforward, leveraging the power of array reversal to achieve the desired result with minimal complexity."
          },
          {
                    "title": "reverse-bits",
                    "solution": "Here's a clear and concise solution for the problem of reversing the bits of a 32-bit unsigned integer based on the provided implementations:\n\n### Solution Explanation\n\nThe task is to reverse the bits of a 32-bit unsigned integer. There are multiple approaches to achieve this. Below are the most efficient and straightforward methods:\n\n#### Method 1: Iterative Approach\n\nThis method involves shifting bits from the original number while constructing the reversed number.\n\n```java\npublic int reverseBits(int n) {\n    int result = 0;\n    for (int i = 0; i < 32; i++) {\n        result <<= 1;               // Shift result left to make space for the next bit\n        result += n & 1;           // Add the last bit of n to result\n        n >>>= 1;                  // Shift n right to process the next bit (unsigned right shift)\n    }\n    return result;\n}\n```\n\n### Explanation of the Iterative Method:\n\n1. Initialize `result` to `0`.\n2. Loop through each of the 32 bits:\n   - Shift `result` left by 1 to create space for the next bit.\n   - Use bitwise AND with `1` to add the least significant bit from `n` to `result`.\n   - Perform an unsigned right shift on `n` to drop the bit just processed.\n3. After 32 iterations, `result` holds the reversed bits of `n`.\n\n#### Method 2: Efficient Byte-Reversal with Caching (if needed for multiple calls)\n\nThis method divides the integer into bytes, reverses each byte, and combines them back.\n\n```java\nprivate final Map<Byte, Integer> cache = new HashMap<>();\n\npublic int reverseBits(int n) {\n    byte[] bytes = new byte[4];\n    for (int i = 0; i < 4; i++) {\n        bytes[i] = (byte)((n >>> (8 * i)) & 0xFF); // Extract each byte\n    }\n    int result = 0;\n    for (int i = 0; i < 4; i++) {\n        result += reverseByte(bytes[i]);\n        if (i < 3) result <<= 8; // Prepare for the next byte\n    }\n    return result;\n}\n\nprivate int reverseByte(byte b) {\n    Integer value = cache.get(b);\n    if (value != null) return value;\n\n    value = 0;\n    for (int i = 0; i < 8; i++) {\n        value += ((b >>> i) & 1);\n        if (i < 7) value <<= 1;\n    }\n    cache.put(b, value); // Store the result in cache\n    return value;\n}\n```\n\n### Summary\n\nBoth methods effectively reverse the bits of a 32-bit integer. The iterative method is straightforward and efficient for a single call, while the byte-reversal method with caching is optimal for multiple calls, minimizing repetitive calculations by storing results."
          },
          {
                    "title": "number-of-1-bits",
                    "solution": "Here's a concise solution for the Hamming weight problem, which counts the number of `1` bits in the binary representation of an integer. I'll summarize the two main approaches provided and present them clearly:\n\n### Solution 1: Counting Set Bits Using Bit Manipulation\n\nThis method uses a common bit manipulation trick where `n & (n - 1)` clears the lowest set bit of `n`. We repeat this until `n` becomes zero, counting the number of operations which gives the count of `1`s.\n\n#### Java Implementation:\n```java\npublic class Solution {\n    public int hammingWeight(int n) {\n        int count = 0;\n        while (n != 0) {\n            n &= (n - 1); // Remove the lowest set bit\n            count++;\n        }\n        return count;\n    }\n}\n```\n\n#### Python Implementation:\n```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        count = 0\n        while n:\n            n &= (n - 1)  # Remove the lowest set bit\n            count += 1\n        return count\n```\n\n### Solution 2: Direct Bit Counting Using Bit Masks\n\nThis approach employs a series of bitwise operations to aggregate the bits in groups and count them efficiently with fewer iterations:\n\n#### Python Implementation:\n```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        n = (n & 0x55555555) + ((n >> 1) & 0x55555555)\n        n = (n & 0x33333333) + ((n >> 2) & 0x33333333)\n        n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F)\n        n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF)\n        n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF)\n        return n\n```\n\n### Additional Approaches Using Built-in Functions\n\n1. **Using Python's built-in count method**:\n```python\nclass Solution:\n    def hammingWeight(self, n: int) -> int:\n        return bin(n).count('1')\n```\n\n2. **Using C++ built-in functions**:\n   - Using `__builtin_popcount`:\n   ```cpp\n   class Solution {\n   public:\n       int hammingWeight(uint32_t n) {\n           return __builtin_popcount(n);\n       }\n   };\n   ```\n   - Using `bitset`:\n   ```cpp\n   class Solution {\n   public:\n       int hammingWeight(uint32_t n) {\n           return bitset<32>(n).count();\n       }\n   };\n   ```\n\n### Summary\n- **First Solution:** Efficiently counts the number of `1` bits by clearing them one at a time.\n- **Second Solution:** Uses bit manipulation to group and count bits very efficiently.\n- **Additional Methods:** Utilize built-in functions to simplify and speed up the process.\n\nChoose the approach that best fits your needs based on clarity, performance, or language features."
          },
          {
                    "title": "house-robber",
                    "solution": "Here's a clear and concise solution for the \"House Robber\" problem, which avoids robbing two adjacent houses:\n\n### Problem Statement\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police by robbing two adjacent houses.\n\n### Approach\nWe can use dynamic programming to break down the problem. For each house, we have two options:\n1. Rob the current house and add its value to the maximum loot excluding the previous house.\n2. Skip the current house and take the maximum loot from the previous house.\n\nThe recursive relation can be stated as:\n- `f(k) = max(f(k-1), nums[k] + f(k-2))`\n\nWhere:\n- `f(k)` is the maximum loot from the first `k` houses.\n\n### Steps for the Solution\n1. Handle base cases directly for the first two houses.\n2. Use two variables to keep track of the maximum loot we can have, thus optimizing space complexity.\n\n### Implementation\n\nHere's the Python implementation:\n\n```python\nclass Solution:\n    def rob(self, nums):\n        prev_no = 0  # Maximum loot when not robbing the current house\n        prev_yes = 0  # Maximum loot when robbing the current house\n        \n        for n in nums:\n            temp = prev_no\n            prev_no = max(prev_no, prev_yes)  # Update maximum loot without current house\n            prev_yes = n + temp  # Update maximum loot including current house\n        \n        return max(prev_no, prev_yes)  # Maximum of both scenarios\n```\n\n### Complexity\n- **Time Complexity**: O(N) where N is the number of houses, as we iterate through the list once.\n- **Space Complexity**: O(1) since we are using only constant space for the variables.\n\nThis solution efficiently calculates the maximum amount that can be robbed without ever having to store results for all houses, relying only on the previous two results to derive the current maximum."
          },
          {
                    "title": "number-of-islands",
                    "solution": "Here is a clear and concise solution for the \"Number of Islands\" problem based on the approaches provided:\n\n### Python Solution (DFS)\n\n```python\nclass Solution:\n    def numIslands(self, grid):\n        if not grid:\n            return 0\n        \n        count = 0\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1':\n                    self.dfs(grid, i, j)\n                    count += 1\n        return count\n\n    def dfs(self, grid, i, j):\n        if i < 0 or j < 0 or i >= len(grid) or j >= len(grid[0]) or grid[i][j] != '1':\n            return\n        grid[i][j] = '0'  # Mark as visited\n        self.dfs(grid, i + 1, j)\n        self.dfs(grid, i - 1, j)\n        self.dfs(grid, i, j + 1)\n        self.dfs(grid, i, j - 1)\n```\n\n### Java Solution (BFS)\n\n```java\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Solution {\n    public int numIslands(char[][] grid) {\n        if (grid == null || grid.length == 0) return 0;\n\n        int count = 0;\n        int m = grid.length, n = grid[0].length;\n        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    count++;\n                    grid[i][j] = '0'; // Mark as visited\n                    Queue<int[]> queue = new LinkedList<>();\n                    queue.add(new int[]{i, j});\n                    \n                    while (!queue.isEmpty()) {\n                        int[] point = queue.poll();\n                        for (int[] direction : directions) {\n                            int r = point[0] + direction[0];\n                            int c = point[1] + direction[1];\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == '1') {\n                                grid[r][c] = '0'; // Mark as visited\n                                queue.add(new int[]{r, c});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n}\n```\n\n### C++ Solution (BFS)\n\n```cpp\n#include <vector>\n#include <queue>\n\nclass Solution {\npublic:\n    int numIslands(std::vector<std::vector<char>>& grid) {\n        int m = grid.size(), n = m ? grid[0].size() : 0, islands = 0;\n        int offsets[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    islands++;\n                    grid[i][j] = '0'; // Mark as visited\n                    std::queue<std::pair<int, int>> todo;\n                    todo.push({i, j});\n                    \n                    while (!todo.empty()) {\n                        auto p = todo.front();\n                        todo.pop();\n                        for (auto& offset : offsets) {\n                            int r = p.first + offset[0], c = p.second + offset[1];\n                            if (r >= 0 && r < m && c >= 0 && c < n && grid[r][c] == '1') {\n                                grid[r][c] = '0'; // Mark as visited\n                                todo.push({r, c});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return islands;\n    }\n};\n```\n\n### Union-Find Solution (Java)\n\n```java\npublic class Solution {\n    class UnionFind {\n        int[] parent;\n        int count;\n\n        UnionFind(char[][] grid) {\n            int m = grid.length;\n            int n = grid[0].length;\n            parent = new int[m * n];\n            count = 0;\n\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (grid[i][j] == '1') {\n                        int id = i * n + j;\n                        parent[id] = id;\n                        count++;\n                    }\n                }\n            }\n        }\n\n        int find(int node) {\n            if (parent[node] != node) {\n                parent[node] = find(parent[node]);\n            }\n            return parent[node];\n        }\n\n        void union(int node1, int node2) {\n            int root1 = find(node1);\n            int root2 = find(node2);\n            if (root1 != root2) {\n                parent[root1] = root2;\n                count--;\n            }\n        }\n    }\n\n    public int numIslands(char[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\n\n        UnionFind uf = new UnionFind(grid);\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int[][] directions = {{1,0},{-1,0},{0,1},{0,-1}};\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == '1') {\n                    grid[i][j] = '0'; // Mark as visited\n                    for (int[] d : directions) {\n                        int x = i + d[0];\n                        int y = j + d[1];\n                        if (x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] == '1') {\n                            uf.union(i * cols + j, x * cols + y);\n                        }\n                    }\n                }\n            }\n        }\n        return uf.count;\n    }\n}\n```\n\nThis consolidated solution illustrates several methods to solve the \"Number of Islands\" problem using Depth-First Search (DFS), Breadth-First Search (BFS), and Union-Find (Disjoint Set). Each section presents a complete, independent solution for better understanding and reuse."
          },
          {
                    "title": "happy-number",
                    "solution": "Here's a clear and concise solution to the problem of determining whether a number is a \"happy number.\" This solution utilizes the Floyd's Cycle Detection algorithm.\n\n## Problem Description\nA \"happy number\" is defined by the following process: starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until you reach 1 (where it will stay) or you enter a loop that does not include 1. If you eventually reach 1, then the number is considered happy.\n\n## Solution\n\n### Approach\nWe can use Floyd's Cycle Detection algorithm, also known as the tortoise and hare approach, to detect cycles in the sequence of numbers generated by summing the squares of the digits. If we reach 1, the number is happy; if we cycle back to a previous number without reaching 1, it is not.\n\n### Code\n\n```java\nclass Solution {\n    public boolean isHappy(int n) {\n        int slow = n; // Tortoise\n        int fast = n; // Hare\n        do {\n            slow = square(sumOfSquares(slow)); // Move slow by 1 step\n            fast = square(sumOfSquares(sumOfSquares(fast))); // Move fast by 2 steps\n        } while (slow != fast);\n\n        // Check if we ended at 1, meaning it's a happy number\n        return slow == 1;\n    }\n\n    // Helper method to calculate sum of squares of digits\n    private int sumOfSquares(int num) {\n        int total = 0;\n        while (num > 0) {\n            int digit = num % 10;\n            total += digit * digit;\n            num /= 10;\n        }\n        return total;\n    }\n}\n```\n\n### Complexity Analysis\n- **Time Complexity:** O(log N) where N is the input number since we are reducing the number of digits in each iteration.\n- **Space Complexity:** O(1) for the fast and slow pointer variables.\n\nThis implementation efficiently determines whether a number is happy using the cycle detection technique, making it optimal in both time and space complexity."
          },
          {
                    "title": "count-primes",
                    "solution": "Here is a concise and clear solution to the problem of counting prime numbers less than a given integer \\( n \\), using the Sieve of Eratosthenes algorithm.\n\n### Java Solution:\n```java\nclass Solution {\n    public int countPrimes(int n) {\n        if (n < 3) return 0; // There are no primes less than 3\n        \n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true); // Assume all numbers are prime initially\n        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n        \n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                // Mark all multiples of i as non-prime\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        // Count the number of primes\n        int count = 0;\n        for (boolean prime : isPrime) {\n            if (prime) count++;\n        }\n        return count;\n    }\n}\n```\n\n### Python Solution:\n```python\nclass Solution:\n    def countPrimes(self, n: int) -> int:\n        if n < 3: return 0  # There are no primes less than 3\n        \n        isPrime = [True] * n\n        isPrime[0] = isPrime[1] = False  # 0 and 1 are not prime numbers\n        \n        for i in range(2, int(n ** 0.5) + 1):\n            if isPrime[i]:\n                # Mark all multiples of i as non-prime\n                isPrime[i*i:n:i] = [False] * ((n - 1 - i*i) // i + 1)\n        \n        return sum(isPrime)  # Count the number of primes\n```\n\n### Explanation:\n1. **Initialization**: Start by creating a boolean array (or list) `isPrime` where each index represents whether the number is prime. Initialize the first two indices (0 and 1) to `false` since they are not prime.\n2. **Main Loop**: For each number starting from 2, mark all its multiples as not prime. This is done up to the square root of `n` for efficiency.\n3. **Count Primes**: Finally, iterate through the `isPrime` array (or list) to count how many `true` values (primes) there are and return the count.\n\nThis algorithm is efficient and has a time complexity of \\( O(n \\log \\log n) \\), which is very suitable for this kind of problem."
          },
          {
                    "title": "reverse-linked-list",
                    "solution": "Here is a concise and clear solution for the problem of reversing a linked list, presented in both iterative and recursive approaches:\n\n### Iterative Approach\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode current = head;\n\n        while (current != null) {\n            ListNode next = current.next; // Store next node\n            current.next = prev;          // Reverse the link\n            prev = current;               // Move prev to current\n            current = next;               // Move to next node\n        }\n        return prev; // New head of the reversed list\n    }\n}\n```\n\n**Complexity**:\n- Time Complexity: O(N)\n- Space Complexity: O(1)\n\n### Recursive Approach\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null) return head; // Base case\n        ListNode newHead = reverseList(head.next); // Reverse rest of the list\n        head.next.next = head; // Reverse the link\n        head.next = null; // Set the next of the current node to null\n        return newHead; // Return the new head of the reversed list\n    }\n}\n```\n\n**Complexity**:\n- Time Complexity: O(N)\n- Space Complexity: O(N) due to call stack in recursion\n\nThese solutions effectively reverse a linked list by manipulating the `next` pointers of the nodes, using either an iterative or a recursive method."
          },
          {
                    "title": "course-schedule",
                    "solution": "To determine if all courses can be finished given a set of prerequisites, we can utilize graph theory. This problem can be restated as detecting a cycle in a directed graph. We can solve this using both Depth-First Search (DFS) and Breadth-First Search (BFS) using a topological sort approach.\n\n### Approach 1: DFS\n\n1. **Create an Adjacency List**: Build an adjacency list from the given prerequisites.\n2. **Track the State of Each Node**: Use a list to track the state of each node:\n   - `0`: Not visited\n   - `-1`: Being visited (indicates a cycle if we encounter this state again)\n   - `1`: Fully processed\n\n3. **DFS Function**: Implement a recursive DFS function to explore nodes and their neighbors according to their state.\n\nHere is the implementation in Python:\n\n```python\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        adjList = [[] for _ in range(numCourses)]\n        for next_course, prev_course in prerequisites:\n            adjList[prev_course].append(next_course)\n\n        state = [0] * numCourses\n\n        def hasCycle(v):\n            if state[v] == -1:  # Cycle detected\n                return True\n            if state[v] == 1:  # Already processed\n                return False\n\n            state[v] = -1  # Mark as being visited\n            for neighbor in adjList[v]:\n                if hasCycle(neighbor):\n                    return True\n            \n            state[v] = 1  # Mark as fully processed\n            return False\n\n        for i in range(numCourses):\n            if hasCycle(i):\n                return False\n        \n        return True\n```\n\n### Approach 2: BFS (Kahn's Algorithm)\n\n1. **Create an Adjacency List**: Similar to the DFS approach.\n2. **Calculate In-Degrees**: Count the number of incoming edges for each node.\n3. **Initialize a Queue**: Add all nodes with an in-degree of zero to a queue.\n4. **Process the Queue**: Repeatedly dequeue nodes, reduce the in-degrees of their neighbors, and add new nodes with zero in-degree to the queue.\n\nHere is the implementation in Python:\n\n```python\nfrom collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        adjList = [[] for _ in range(numCourses)]\n        inDegree = [0] * numCourses\n        \n        for next_course, prev_course in prerequisites:\n            adjList[prev_course].append(next_course)\n            inDegree[next_course] += 1\n\n        queue = deque([i for i in range(numCourses) if inDegree[i] == 0])\n        count = 0  # Count of processed nodes\n\n        while queue:\n            current_course = queue.popleft()\n            count += 1  # Process this course\n            \n            for neighbor in adjList[current_course]:\n                inDegree[neighbor] -= 1\n                if inDegree[neighbor] == 0:\n                    queue.append(neighbor)\n\n        return count == numCourses  # If count matches numCourses, all courses can be finished\n```\n\n### Complexity Analysis\n\n- Time Complexity: O(V + E) where V is the number of vertices (courses) and E is the number of edges (prerequisites).\n- Space Complexity: O(V + E) for storing the adjacency list and in-degrees.\n\nBoth approaches effectively check for cycles in the course schedule using the respective graph traversal techniques."
          },
          {
                    "title": "implement-trie-prefix-tree",
                    "solution": "Here’s a clear and concise implementation of a Trie (Prefix Tree) data structure based on the various provided solutions:\n\n### C++ Implementation\n\n```cpp\nclass TrieNode {\npublic:\n    TrieNode *children[26]{};\n    bool is_word = false;\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\n\npublic:\n    Trie() {\n        root = new TrieNode();\n    }\n\n    void insert(const string &word) {\n        TrieNode *node = root;\n        for (char c : word) {\n            int index = c - 'a';\n            if (!node->children[index]) {\n                node->children[index] = new TrieNode();\n            }\n            node = node->children[index];\n        }\n        node->is_word = true;\n    }\n\n    bool search(const string &word) {\n        TrieNode *node = root;\n        for (char c : word) {\n            int index = c - 'a';\n            if (!node->children[index]) return false;\n            node = node->children[index];\n        }\n        return node->is_word;\n    }\n\n    bool startsWith(const string &prefix) {\n        TrieNode *node = root;\n        for (char c : prefix) {\n            int index = c - 'a';\n            if (!node->children[index]) return false;\n            node = node->children[index];\n        }\n        return true;\n    }\n};\n```\n\n### Python Implementation\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for letter in word:\n            if letter not in node.children:\n                node.children[letter] = TrieNode()\n            node = node.children[letter]\n        node.is_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for letter in word:\n            if letter not in node.children:\n                return False\n            node = node.children[letter]\n        return node.is_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for letter in prefix:\n            if letter not in node.children:\n                return False\n            node = node.children[letter]\n        return True\n```\n\n### Java Implementation\n\n```java\nclass TrieNode {\n    TrieNode[] children = new TrieNode[26];\n    boolean isWord = false;\n}\n\nclass Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            int index = c - 'a';\n            if (node.children[index] == null) {\n                node.children[index] = new TrieNode();\n            }\n            node = node.children[index];\n        }\n        node.isWord = true;\n    }\n\n    public boolean search(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            int index = c - 'a';\n            if (node.children[index] == null) return false;\n            node = node.children[index];\n        }\n        return node.isWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        TrieNode node = root;\n        for (char c : prefix.toCharArray()) {\n            int index = c - 'a';\n            if (node.children[index] == null) return false;\n            node = node.children[index];\n        }\n        return true;\n    }\n}\n```\n\n### Explanation\n- **TrieNode**: Represents each node in the Trie. Each node keeps track of its children (for each character) and whether it marks the end of a word.\n- **Trie**: The main data structure that allows inserting words, searching for exact matches, and checking if any words start with a given prefix.\n- **Insert**: For each character in the word, if the corresponding child node doesn't exist, create it. Mark the ending node as a word.\n- **Search**: Traverse through each character and check for its existence. Finally, check if the end node represents a complete word.\n- **StartsWith**: Similar to search but returns true if the prefix is found, regardless of whether it completes a word."
          },
          {
                    "title": "course-schedule-ii",
                    "solution": "To solve the problem of determining the order in which prerequisite courses must be taken, we can represent the problem as a directed graph and apply topological sorting. Below is a concise implementation using both BFS and DFS approaches.\n\n### Problem Overview\nGiven `numCourses` and an array of prerequisites `prerequisites` where each pair `[a, b]` indicates that course `a` is a prerequisite of course `b`, we need to return an order of courses to complete all prerequisites or an empty array if it is not possible.\n\n### Solution - Topological Sort Using BFS (Kahn's Algorithm)\n\n```java\nimport java.util.*;\n\nclass Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        // Build the graph and calculate indegrees\n        int[] indegree = new int[numCourses];\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) graph.add(new ArrayList<>());\n\n        for (int[] pair : prerequisites) {\n            indegree[pair[0]]++;\n            graph.get(pair[1]).add(pair[0]); // Edge from pair[1] to pair[0]\n        }\n\n        // Prepare to perform BFS\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0) queue.offer(i);\n        }\n\n        List<Integer> order = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            order.add(current);\n            for (int neighbor : graph.get(current)) {\n                indegree[neighbor]--;\n                if (indegree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        // Check if we could include all courses\n        return order.size() == numCourses ? order.stream().mapToInt(i -> i).toArray() : new int[0];\n    }\n}\n```\n\n### Solution - Topological Sort Using DFS\n\n```java\nimport java.util.*;\n\nclass Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) graph.add(new ArrayList<>());\n\n        int[] indegree = new int[numCourses];\n        for (int[] pair : prerequisites) {\n            graph.get(pair[1]).add(pair[0]); // Edge from pair[1] to pair[0]\n            indegree[pair[0]]++;\n        }\n\n        boolean[] visited = new boolean[numCourses];\n        boolean[] onStack = new boolean[numCourses]; // To detect cycles\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (!visited[i] && !dfs(graph, i, visited, onStack, stack)) {\n                return new int[0]; // Cycle detected\n            }\n        }\n\n        // Convert stack to output array\n        int[] order = new int[numCourses];\n        for (int i = 0; i < numCourses; i++) order[i] = stack.poll();\n        return order;\n    }\n\n    private boolean dfs(List<List<Integer>> graph, int node, boolean[] visited, boolean[] onStack, Deque<Integer> stack) {\n        if (onStack[node]) return false; // Cycle detected\n        if (visited[node]) return true; // Already visited\n\n        visited[node] = true;\n        onStack[node] = true;\n\n        for (int neighbor : graph.get(node)) {\n            if (!dfs(graph, neighbor, visited, onStack, stack)) {\n                return false;\n            }\n        }\n\n        onStack[node] = false; // Backtrack\n        stack.push(node);\n        return true;\n    }\n}\n```\n\n### Explanation\n1. **Graph Representation**: We create an adjacency list for the graph based on the prerequisites and calculate the indegrees of each course.\n2. **BFS Approach**: We utilize a queue to maintain courses with zero indegrees (no prerequisites). We process each course, decrement the indegrees of its neighbors, and add newly available courses to the queue.\n3. **DFS Approach**: We recursively visit each course, track the visited status and currently visiting status (to detect cycles), and use a stack to record the order of courses. \n\nBoth approaches result in a time complexity of O(N + E) where N is the number of courses and E is the number of prerequisites, and handle the cyclic dependencies by checking the indegree or utilizing the visiting stack accordingly."
          },
          {
                    "title": "word-search-ii",
                    "solution": "Here is a clear and concise solution using a Backtracking approach combined with a Trie data structure for the given problem:\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass TrieNode {\n    TrieNode[] next = new TrieNode[26];\n    String word = null; // Store the word at the leaf node\n}\n\nclass Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    // Insert a word into the Trie\n    public void insert(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            if (node.next[c - 'a'] == null) {\n                node.next[c - 'a'] = new TrieNode();\n            }\n            node = node.next[c - 'a'];\n        }\n        node.word = word; // mark the end of a word\n    }\n\n    public TrieNode getRoot() {\n        return root;\n    }\n}\n\npublic class Solution {\n    private List<String> result = new ArrayList<>();\n    private char[][] board;\n\n    public List<String> findWords(char[][] board, String[] words) {\n        this.board = board;\n        Trie trie = new Trie();\n        for (String word : words) {\n            trie.insert(word);\n        }\n\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                dfs(i, j, trie.getRoot());\n            }\n        }\n\n        return result;\n    }\n\n    private void dfs(int i, int j, TrieNode node) {\n        char c = board[i][j];\n        if (c == '#' || node.next[c - 'a'] == null) return; // Out of bounds or not a valid path\n\n        node = node.next[c - 'a'];\n        if (node.word != null) { // Found a valid word\n            result.add(node.word);\n            node.word = null; // Avoid duplicates\n        }\n\n        board[i][j] = '#'; // Mark the cell as visited\n        if (i > 0) dfs(i - 1, j, node); // Up\n        if (j > 0) dfs(i, j - 1, node); // Left\n        if (i < board.length - 1) dfs(i + 1, j, node); // Down\n        if (j < board[0].length - 1) dfs(i, j + 1, node); // Right\n        board[i][j] = c; // Restore the cell value\n    }\n}\n```\n\n### Explanation:\n1. **Trie Structure**: The solution starts by defining a `TrieNode` class for the Trie structure and a `Trie` class that allows insertion of words.\n2. **Inserting Words**: Each word from the provided array is inserted into the Trie.\n3. **Depth-First Search (DFS)**: The algorithm then iterates over each cell in the board. It performs DFS to explore all possible paths:\n   - If the current character is valid and leads to a Trie node, it continues.\n   - If a word is found, it is added to the results and marked to prevent duplicates.\n   - The cell is marked as visited (using a placeholder character), and the function explores all four possible directions.\n   - Finally, the current cell is restored to allow it to be considered in other paths.\n4. **Return Result**: The function returns the list of found words once all cells have been processed.\n\nThis implementation efficiently leverages the Trie structure to prune unnecessary searches and utilizes backtracking to traverse the board."
          },
          {
                    "title": "kth-largest-element-in-an-array",
                    "solution": "Here’s a clear and concise solution to the \"Kth Largest Element in an Array\" problem, utilizing various approaches:\n\n### Problem Statement\nGiven an integer array `nums` and an integer `k`, return the `k`th largest element in the array.\n\n### Approach 1: Sorting\nThe simplest approach is to sort the array and return the element at the `k-1` index from the end.\n\n#### Code (Python)\n```python\ndef findKthLargest(nums, k):\n    return sorted(nums, reverse=True)[k-1]\n```\n\n### Approach 2: Min-Heap\nYou can also use a min-heap to keep track of the top `k` largest elements. The root of the heap will represent the `k`th largest element.\n\n#### Code (Python)\n```python\nimport heapq\n\ndef findKthLargest(nums, k):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap[0]\n```\n\n### Approach 3: Quick Selection\nThis method is based on the partitioning logic of QuickSort and can achieve an average time complexity of O(N). The idea is to pick a pivot and partition the array such that elements greater than the pivot are on one side, and those less than the pivot are on the other side.\n\n#### Code (Python)\n```python\nimport random\n\ndef findKthLargest(nums, k):\n    def partition(left, right, pivot_index):\n        pivot = nums[pivot_index]\n        nums[pivot_index], nums[right] = nums[right], nums[pivot_index]\n        store_index = left\n        for i in range(left, right):\n            if nums[i] > pivot:  # > for kth largest\n                nums[store_index], nums[i] = nums[i], nums[store_index]\n                store_index += 1\n        nums[right], nums[store_index] = nums[store_index], nums[right]\n        return store_index\n\n    left, right = 0, len(nums) - 1\n    while True:\n        pivot_index = random.randint(left, right)\n        new_pivot_index = partition(left, right, pivot_index)\n        # Check the position of the pivot\n        if new_pivot_index == k - 1:\n            return nums[new_pivot_index]\n        elif new_pivot_index < k - 1:\n            left = new_pivot_index + 1\n        else:\n            right = new_pivot_index - 1\n```\n\n### Conclusion\n- **Sorting**: O(N log N) time complexity, straightforward but not optimal for large inputs.\n- **Min-Heap**: O(N log k) time complexity, efficient for finding the `k`th largest element without sorting the entire array.\n- **Quick Selection**: Average O(N) time complexity, best for large datasets and avoids full sorting.\n\nChoose the approach that best fits the problem constraints regarding time and space efficiency."
          },
          {
                    "title": "contains-duplicate",
                    "solution": "Here's a clear and concise solution to the \"Contains Duplicate\" problem based on the provided user's approaches:\n\n## Problem Statement:\nGiven an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.\n\n## Approach 1: Brute Force\n### Intuition:\nCompare each element with every other element in the array to find duplicates.  \n### Time Complexity: O(n^2), Space Complexity: O(1)\n### Code:\n```cpp\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] == nums[j]) return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n## Approach 2: Sorting\n### Intuition:\nSort the array. Check for adjacent elements to see if they are the same.\n### Time Complexity: O(n log n), Space Complexity: O(1)\n### Code:\n```cpp\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i] == nums[i - 1]) return true;\n        }\n        return false;\n    }\n};\n```\n\n## Approach 3: Hash Set\n### Intuition:\nUse a hash set to track encountered elements. If an element is found again, return `true`.\n### Time Complexity: O(n), Space Complexity: O(n)\n### Code:\n```cpp\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_set<int> seen;\n        for (int num : nums) {\n            if (seen.count(num)) return true;\n            seen.insert(num);\n        }\n        return false;\n    }\n};\n```\n\n## Approach 4: Hash Map\n### Intuition:\nCount occurrences of each element using a hash map. If an element’s count exceeds one, return `true`.\n### Time Complexity: O(n), Space Complexity: O(n)\n### Code:\n```cpp\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_map<int, int> count;\n        for (int num : nums) {\n            if (++count[num] > 1) return true;\n        }\n        return false;\n    }\n};\n```\n\n## Conclusion:\nThe hash set approach is generally the most efficient with O(n) time complexity, making it suitable for larger datasets. The brute force approach is simple but not scalable for large inputs. Sorting is also effective but has a higher time complexity due to the sort operation. \n\nHappy coding!"
          }
]